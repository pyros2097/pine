trait Any

trait Node
  name(): String

enum BooleanOperator
  And
  Or
  Not

type BooleanOps = And | Or | Not

// TODO: all these errors must be handled in the parser and an error should never happen
// here as these are purely computational stuff
// No errors can happen in this language

Class NotExpression
  argument: Node

  eval(): Bool, err =>
    if argument.Type() == "Boolean" then
      return argument.Not(), nil
    else
      return "", error "Not Expression requires a boolean expression but given ${argument}"
    end

class ReturnExpression
  caller: FuncExpression
  arguments: Array[Node]

  eval() =>
    // TODO: check if the function in which the return statement is called returns the right type
    // if arguments is empty return empty

class BooleanExpression
  var operator: BooleanOperator
  var left: BooleanLiteral
  var right: BooleanLiteral

  fun eval(): Bool, err =>
    match operator
    | And -> {
      if left then
       if right then
         return true
       end
      end
      false
    }
    | Or -> {
      if left then return true end
      if right the return true end
      false
    }
    else
      return nil, error "Logical Expression requires a "
    end


enum LogicalOperator
  GreaterThan
  Greater
  Equal
  NotEqual
  LessThan
  Less

// left and right can be any one
// "BinaryLogicalExpression",
// "BinaryArithmeticExpression",
// "CallExpression",
// "MemberExpression",
// "StringLiteral",
// "NumberLiteral",
// "BooleanLiteral",
// "ExternalLiteral",
// "Identifier",
class LogicalExpression
  operator LogicalOperator
  left     BooleanLiteral | Identifier | CallExpression | LogicalExpression | ArithmeticExpresion
  right    BooleanLiteral


enum ArithmeticOperator
  Add
  Sub
  Div
  Mul

class ArithmeticExpression
  operator ArithmeticOperator
  left     Identifier | CallExpression<Returning(IDen| Arith)> | ArithmeticExpresion
  right    Identifier | CallExpression | ArithmeticExpresion

// error("Identifier ${name} not found")
class Identifier
  name      String
  address   Number
  value     Any
  type      Type
  processed Bool

  eval(context) =>
    if processed then
      node
    else
      if value, exists := context.SymbolTable[node.Name]; exists then
        node.Address = &value
        node.Value = value
        node.Type = context.SymbolType[node.Name]
        node.processed = true
        node.Value
      end
    end

class CallExpression
  callee    Node
  arguments Array<Node>

  eval() =>
    callee.eval(ctx)
    call(ctx, callee, args)

class BlockExpression
  body Array[Node]

class Program
  body Array<Node>

  eval() =>
    for exp in body do
      exp.eval(ctx)
    end