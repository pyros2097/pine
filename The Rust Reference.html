<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>The Rust Reference</title>

    <link rel="stylesheet" type="text/css" href="The%20Rust%20Reference_files/rust.css">

    <link rel="shortcut icon" href="https://www.rust-lang.org/favicon.ico">

<style>
  /* Display the full TOC */
  nav {
    column-count: auto;
    -moz-column-count: auto;
    -webkit-column-count: auto;
  }
  nav ul ul {
    display: block;
    padding-left: 2em;
  }
  #influences blockquote p:last-child {
    color: #999;
  }
</style>


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="versioninfo">
  <img src="The%20Rust%20Reference_files/rust-logo-32x32-blk.png" alt="" height="32" width="32"><br>
  <span class="white-sticker"><a href="https://www.rust-lang.org/">Rust</a> 1.4.0</span><br>
  <a href="https://github.com/rust-lang/rust/commit/8ab8581f6921bc7a8e3fa4defffd2814372dcb15" class="hash white-sticker">8ab8581f6</a>
</div>


    <h1 class="title">The Rust Reference</h1>
    <nav id="TOC"><ul>
<li><a href="#introduction">1 Introduction</a><ul></ul></li>
<li><a href="#notation">2 Notation</a><ul>
<li><a href="#unicode-productions">2.1 Unicode productions</a><ul></ul></li>
<li><a href="#string-table-productions">2.2 String table productions</a><ul></ul></li></ul></li>
<li><a href="#lexical-structure">3 Lexical structure</a><ul>
<li><a href="#input-format">3.1 Input format</a><ul></ul></li>
<li><a href="#identifiers">3.2 Identifiers</a><ul></ul></li>
<li><a href="#comments">3.3 Comments</a><ul></ul></li>
<li><a href="#whitespace">3.4 Whitespace</a><ul></ul></li>
<li><a href="#tokens">3.5 Tokens</a><ul>
<li><a href="#literals">3.5.1 Literals</a><ul>
<li><a href="#examples">3.5.1.1 Examples</a><ul>
<li><a href="#characters-and-strings">3.5.1.1.1 Characters and strings</a><ul></ul></li>
<li><a href="#byte-escapes">3.5.1.1.2 Byte escapes</a><ul></ul></li>
<li><a href="#unicode-escapes">3.5.1.1.3 Unicode escapes</a><ul></ul></li>
<li><a href="#numbers">3.5.1.1.4 Numbers</a><ul></ul></li>
<li><a href="#suffixes">3.5.1.1.5 Suffixes</a><ul></ul></li></ul></li>
<li><a href="#character-and-string-literals">3.5.1.2 Character and string literals</a><ul>
<li><a href="#character-literals">3.5.1.2.1 Character literals</a><ul></ul></li>
<li><a href="#string-literals">3.5.1.2.2 String literals</a><ul></ul></li>
<li><a href="#character-escapes">3.5.1.2.3 Character escapes</a><ul></ul></li>
<li><a href="#raw-string-literals">3.5.1.2.4 Raw string literals</a><ul></ul></li></ul></li>
<li><a href="#byte-and-byte-string-literals">3.5.1.3 Byte and byte string literals</a><ul>
<li><a href="#byte-literals">3.5.1.3.1 Byte literals</a><ul></ul></li>
<li><a href="#byte-string-literals">3.5.1.3.2 Byte string literals</a><ul></ul></li>
<li><a href="#raw-byte-string-literals">3.5.1.3.3 Raw byte string literals</a><ul></ul></li></ul></li>
<li><a href="#number-literals">3.5.1.4 Number literals</a><ul>
<li><a href="#integer-literals">3.5.1.4.1 Integer literals</a><ul></ul></li>
<li><a href="#floating-point-literals">3.5.1.4.2 Floating-point literals</a><ul></ul></li></ul></li>
<li><a href="#boolean-literals">3.5.1.5 Boolean literals</a><ul></ul></li></ul></li>
<li><a href="#symbols">3.5.2 Symbols</a><ul></ul></li></ul></li>
<li><a href="#paths">3.6 Paths</a><ul></ul></li></ul></li>
<li><a href="#syntax-extensions">4 Syntax extensions</a><ul>
<li><a href="#macros">4.1 Macros</a><ul>
<li><a href="#macro-by-example">4.1.1 Macro By Example</a><ul></ul></li>
<li><a href="#parsing-limitations">4.1.2 Parsing limitations</a><ul></ul></li></ul></li></ul></li>
<li><a href="#crates-and-source-files">5 Crates and source files</a><ul></ul></li>
<li><a href="#items-and-attributes">6 Items and attributes</a><ul>
<li><a href="#items">6.1 Items</a><ul>
<li><a href="#type-parameters">6.1.1 Type Parameters</a><ul></ul></li>
<li><a href="#modules">6.1.2 Modules</a><ul>
<li><a href="#extern-crate-declarations">6.1.2.1 Extern crate declarations</a><ul></ul></li>
<li><a href="#use-declarations">6.1.2.2 Use declarations</a><ul></ul></li></ul></li>
<li><a href="#functions">6.1.3 Functions</a><ul>
<li><a href="#generic-functions">6.1.3.1 Generic functions</a><ul></ul></li>
<li><a href="#unsafety">6.1.3.2 Unsafety</a><ul>
<li><a href="#unsafe-functions">6.1.3.2.1 Unsafe functions</a><ul></ul></li>
<li><a href="#unsafe-blocks">6.1.3.2.2 Unsafe blocks</a><ul></ul></li>
<li><a href="#behavior-considered-undefined">6.1.3.2.3 Behavior considered undefined</a><ul></ul></li>
<li><a href="#behavior-not-considered-unsafe">6.1.3.2.4 Behavior not considered unsafe</a><ul></ul></li></ul></li>
<li><a href="#diverging-functions">6.1.3.3 Diverging functions</a><ul></ul></li>
<li><a href="#extern-functions">6.1.3.4 Extern functions</a><ul></ul></li></ul></li>
<li><a href="#type-aliases">6.1.4 Type aliases</a><ul></ul></li>
<li><a href="#structures">6.1.5 Structures</a><ul></ul></li>
<li><a href="#enumerations">6.1.6 Enumerations</a><ul></ul></li>
<li><a href="#constant-items">6.1.7 Constant items</a><ul></ul></li>
<li><a href="#static-items">6.1.8 Static items</a><ul>
<li><a href="#mutable-statics">6.1.8.1 Mutable statics</a><ul></ul></li></ul></li>
<li><a href="#traits">6.1.9 Traits</a><ul></ul></li>
<li><a href="#implementations">6.1.10 Implementations</a><ul></ul></li>
<li><a href="#external-blocks">6.1.11 External blocks</a><ul></ul></li></ul></li>
<li><a href="#visibility-and-privacy">6.2 Visibility and Privacy</a><ul>
<li><a href="#re-exporting-and-visibility">6.2.1 Re-exporting and Visibility</a><ul></ul></li></ul></li>
<li><a href="#attributes">6.3 Attributes</a><ul>
<li><a href="#crate-only-attributes">6.3.1 Crate-only attributes</a><ul></ul></li>
<li><a href="#module-only-attributes">6.3.2 Module-only attributes</a><ul></ul></li>
<li><a href="#function-only-attributes">6.3.3 Function-only attributes</a><ul></ul></li>
<li><a href="#static-only-attributes">6.3.4 Static-only attributes</a><ul></ul></li>
<li><a href="#ffi-attributes">6.3.5 FFI attributes</a><ul></ul></li>
<li><a href="#macro-related-attributes">6.3.6 Macro-related attributes</a><ul></ul></li>
<li><a href="#miscellaneous-attributes">6.3.7 Miscellaneous attributes</a><ul></ul></li>
<li><a href="#conditional-compilation">6.3.8 Conditional compilation</a><ul></ul></li>
<li><a href="#lint-check-attributes">6.3.9 Lint check attributes</a><ul></ul></li>
<li><a href="#language-items">6.3.10 Language items</a><ul></ul></li>
<li><a href="#inline-attributes">6.3.11 Inline attributes</a><ul></ul></li>
<li><a href="#derive">6.3.12 <code>derive</code></a><ul></ul></li>
<li><a href="#compiler-features">6.3.13 Compiler Features</a><ul></ul></li></ul></li></ul></li>
<li><a href="#statements-and-expressions">7 Statements and expressions</a><ul>
<li><a href="#statements">7.1 Statements</a><ul>
<li><a href="#declaration-statements">7.1.1 Declaration statements</a><ul>
<li><a href="#item-declarations">7.1.1.1 Item declarations</a><ul></ul></li>
<li><a href="#variable-declarations">7.1.1.2 Variable declarations</a><ul></ul></li></ul></li>
<li><a href="#expression-statements">7.1.2 Expression statements</a><ul></ul></li></ul></li>
<li><a href="#expressions">7.2 Expressions</a><ul>
<li><a href="#lvalues,-rvalues-and-temporaries">7.2.0.1 Lvalues, rvalues and temporaries</a><ul>
<li><a href="#temporary-lifetimes">7.2.0.1.1 Temporary lifetimes</a><ul></ul></li></ul></li>
<li><a href="#moved-and-copied-types">7.2.0.2 Moved and copied types</a><ul></ul></li>
<li><a href="#literal-expressions">7.2.1 Literal expressions</a><ul></ul></li>
<li><a href="#path-expressions">7.2.2 Path expressions</a><ul></ul></li>
<li><a href="#tuple-expressions">7.2.3 Tuple expressions</a><ul></ul></li>
<li><a href="#structure-expressions">7.2.4 Structure expressions</a><ul></ul></li>
<li><a href="#block-expressions">7.2.5 Block expressions</a><ul></ul></li>
<li><a href="#method-call-expressions">7.2.6 Method-call expressions</a><ul></ul></li>
<li><a href="#field-expressions">7.2.7 Field expressions</a><ul></ul></li>
<li><a href="#array-expressions">7.2.8 Array expressions</a><ul></ul></li>
<li><a href="#index-expressions">7.2.9 Index expressions</a><ul></ul></li>
<li><a href="#range-expressions">7.2.10 Range expressions</a><ul></ul></li>
<li><a href="#unary-operator-expressions">7.2.11 Unary operator expressions</a><ul></ul></li>
<li><a href="#binary-operator-expressions">7.2.12 Binary operator expressions</a><ul>
<li><a href="#arithmetic-operators">7.2.12.1 Arithmetic operators</a><ul></ul></li>
<li><a href="#bitwise-operators">7.2.12.2 Bitwise operators</a><ul></ul></li>
<li><a href="#lazy-boolean-operators">7.2.12.3 Lazy boolean operators</a><ul></ul></li>
<li><a href="#comparison-operators">7.2.12.4 Comparison operators</a><ul></ul></li>
<li><a href="#type-cast-expressions">7.2.12.5 Type cast expressions</a><ul></ul></li>
<li><a href="#assignment-expressions">7.2.12.6 Assignment expressions</a><ul></ul></li>
<li><a href="#compound-assignment-expressions">7.2.12.7 Compound assignment expressions</a><ul></ul></li>
<li><a href="#operator-precedence">7.2.12.8 Operator precedence</a><ul></ul></li></ul></li>
<li><a href="#grouped-expressions">7.2.13 Grouped expressions</a><ul></ul></li>
<li><a href="#call-expressions">7.2.14 Call expressions</a><ul></ul></li>
<li><a href="#lambda-expressions">7.2.15 Lambda expressions</a><ul></ul></li>
<li><a href="#infinite-loops">7.2.16 Infinite loops</a><ul></ul></li>
<li><a href="#break-expressions">7.2.17 Break expressions</a><ul></ul></li>
<li><a href="#continue-expressions">7.2.18 Continue expressions</a><ul></ul></li>
<li><a href="#while-loops">7.2.19 While loops</a><ul></ul></li>
<li><a href="#for-expressions">7.2.20 For expressions</a><ul></ul></li>
<li><a href="#if-expressions">7.2.21 If expressions</a><ul></ul></li>
<li><a href="#match-expressions">7.2.22 Match expressions</a><ul></ul></li>
<li><a href="#if-let-expressions">7.2.23 If let expressions</a><ul></ul></li>
<li><a href="#while-let-loops">7.2.24 While let loops</a><ul></ul></li>
<li><a href="#return-expressions">7.2.25 Return expressions</a><ul></ul></li></ul></li></ul></li>
<li><a href="#type-system">8 Type system</a><ul>
<li><a href="#types">8.1 Types</a><ul>
<li><a href="#primitive-types">8.1.1 Primitive types</a><ul>
<li><a href="#machine-types">8.1.1.1 Machine types</a><ul></ul></li>
<li><a href="#machine-dependent-integer-types">8.1.1.2 Machine-dependent integer types</a><ul></ul></li></ul></li>
<li><a href="#textual-types">8.1.2 Textual types</a><ul></ul></li>
<li><a href="#tuple-types">8.1.3 Tuple types</a><ul></ul></li>
<li><a href="#array,-and-slice-types">8.1.4 Array, and Slice types</a><ul></ul></li>
<li><a href="#structure-types">8.1.5 Structure types</a><ul></ul></li>
<li><a href="#enumerated-types">8.1.6 Enumerated types</a><ul></ul></li>
<li><a href="#recursive-types">8.1.7 Recursive types</a><ul></ul></li>
<li><a href="#pointer-types">8.1.8 Pointer types</a><ul></ul></li>
<li><a href="#function-types">8.1.9 Function types</a><ul>
<li><a href="#function-types-for-specific-items">8.1.9.1 Function types for specific items</a><ul></ul></li></ul></li>
<li><a href="#closure-types">8.1.10 Closure types</a><ul></ul></li>
<li><a href="#trait-objects">8.1.11 Trait objects</a><ul></ul></li>
<li><a href="#type-parameters-1">8.1.12 Type parameters</a><ul></ul></li>
<li><a href="#self-types">8.1.13 Self types</a><ul></ul></li></ul></li>
<li><a href="#subtyping">8.2 Subtyping</a><ul></ul></li>
<li><a href="#type-coercions">8.3 Type coercions</a><ul>
<li><a href="#coercion-sites">8.3.1 Coercion sites</a><ul></ul></li>
<li><a href="#coercion-types">8.3.2 Coercion types</a><ul></ul></li></ul></li></ul></li>
<li><a href="#special-traits">9 Special traits</a><ul>
<li><a href="#the-copy-trait">9.1 The <code>Copy</code> trait</a><ul></ul></li>
<li><a href="#the-sized-trait">9.2 The <code>Sized</code> trait</a><ul></ul></li>
<li><a href="#the-drop-trait">9.3 The <code>Drop</code> trait</a><ul></ul></li>
<li><a href="#the-deref-trait">9.4 The <code>Deref</code> trait</a><ul></ul></li></ul></li>
<li><a href="#memory-model">10 Memory model</a><ul>
<li><a href="#memory-allocation-and-lifetime">10.0.1 Memory allocation and lifetime</a><ul></ul></li>
<li><a href="#memory-ownership">10.0.2 Memory ownership</a><ul></ul></li>
<li><a href="#variables">10.0.3 Variables</a><ul></ul></li></ul></li>
<li><a href="#linkage">11 Linkage</a><ul></ul></li>
<li><a href="#appendix:-rationales-and-design-trade-offs">12 Appendix: Rationales and design trade-offs</a><ul></ul></li>
<li><a href="#appendix:-influences">13 Appendix: Influences</a><ul></ul></li></ul></nav>
<h1 id="introduction" class="section-header"><a href="#introduction">1 Introduction</a></h1>
<p>This document is the primary reference for the Rust programming language. It
provides three kinds of material:</p>

<ul>
<li>Chapters that informally describe each language construct and their use.</li>
<li>Chapters that informally describe the memory model, concurrency model,
runtime services, linkage model and debugging facilities.</li>
<li>Appendix chapters providing rationale and references to languages that
influenced the design.</li>
</ul>

<p>This document does not serve as an introduction to the language. Background
familiarity with the language is assumed. A separate <a href="http://doc.rust-lang.org/book/">book</a> is available to
help acquire such background familiarity.</p>

<p>This document also does not serve as a reference to the <a href="http://doc.rust-lang.org/std/">standard</a> library
included in the language distribution. Those libraries are documented
separately by extracting documentation attributes from their source code. Many
of the features that one might expect to be language features are library
features in Rust, so what you're looking for may be there, not here.</p>

<p>You may also be interested in the <a href="http://doc.rust-lang.org/grammar.html">grammar</a>.</p>

<h1 id="notation" class="section-header"><a href="#notation">2 Notation</a></h1>
<h2 id="unicode-productions" class="section-header"><a href="#unicode-productions">2.1 Unicode productions</a></h2>
<p>A few productions in Rust's grammar permit Unicode code points outside the
ASCII range. We define these productions in terms of character properties
specified in the Unicode standard, rather than in terms of ASCII-range code
points. The grammar has a <a href="http://doc.rust-lang.org/grammar.html#special-unicode-productions">Special Unicode Productions</a>
section that lists these productions.</p>

<h2 id="string-table-productions" class="section-header"><a href="#string-table-productions">2.2 String table productions</a></h2>
<p>Some rules in the grammar — notably <a href="#unary-operator-expressions">unary
operators</a>, <a href="#binary-operator-expressions">binary
operators</a>, and <a href="http://doc.rust-lang.org/grammar.html#keywords">keywords</a> — are
given in a simplified form: as a listing of a table of unquoted, printable
whitespace-separated strings. These cases form a subset of the rules regarding
the <a href="#tokens">token</a> rule, and are assumed to be the result of a
lexical-analysis phase feeding the parser, driven by a DFA, operating over the
disjunction of all such string table entries.</p>

<p>When such a string enclosed in double-quotes (<code>"</code>) occurs inside the grammar,
it is an implicit reference to a single member of such a string table
production. See <a href="#tokens">tokens</a> for more information.</p>

<h1 id="lexical-structure" class="section-header"><a href="#lexical-structure">3 Lexical structure</a></h1>
<h2 id="input-format" class="section-header"><a href="#input-format">3.1 Input format</a></h2>
<p>Rust input is interpreted as a sequence of Unicode code points encoded in UTF-8.
Most Rust grammar rules are defined in terms of printable ASCII-range
code points, but a small number are defined in terms of Unicode properties or
explicit code point lists. <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<h2 id="identifiers" class="section-header"><a href="#identifiers">3.2 Identifiers</a></h2>
<p>An identifier is any nonempty Unicode<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> string of the following form:</p>

<ul>
<li>The first character has property <code>XID_start</code></li>
<li>The remaining characters have property <code>XID_continue</code></li>
</ul>

<p>that does <em>not</em> occur in the set of <a href="http://doc.rust-lang.org/grammar.html#keywords">keywords</a>.</p>

<blockquote>
<p><strong>Note</strong>: <code>XID_start</code> and <code>XID_continue</code> as character properties cover the
character ranges used to form the more familiar C and Java language-family
identifiers.</p>
</blockquote>

<h2 id="comments" class="section-header"><a href="#comments">3.3 Comments</a></h2>
<p>Comments in Rust code follow the general C++ style of line (<code>//</code>) and
block (<code>/* ... */</code>) comment forms. Nested block comments are supported.</p>

<p>Line comments beginning with exactly <em>three</em> slashes (<code>///</code>), and block
comments beginning with exactly one repeated asterisk in the block-open
sequence (<code>/**</code>), are interpreted as a special syntax for <code>doc</code>
<a href="#attributes">attributes</a>. That is, they are equivalent to writing
<code>#[doc="..."]</code> around the body of the comment, i.e., <code>/// Foo</code> turns into
<code>#[doc="Foo"]</code>.</p>

<p>Line comments beginning with <code>//!</code> and block comments beginning with <code>/*!</code> are
doc comments that apply to the parent of the comment, rather than the item
that follows.  That is, they are equivalent to writing <code>#![doc="..."]</code> around
the body of the comment. <code>//!</code> comments are usually used to document
modules that occupy a source file.</p>

<p>Non-doc comments are interpreted as a form of whitespace.</p>

<h2 id="whitespace" class="section-header"><a href="#whitespace">3.4 Whitespace</a></h2>
<p>Whitespace is any non-empty string containing only the following characters:</p>

<ul>
<li><code>U+0020</code> (space, <code>' '</code>)</li>
<li><code>U+0009</code> (tab, <code>'\t'</code>)</li>
<li><code>U+000A</code> (LF, <code>'\n'</code>)</li>
<li><code>U+000D</code> (CR, <code>'\r'</code>)</li>
</ul>

<p>Rust is a "free-form" language, meaning that all forms of whitespace serve only
to separate <em>tokens</em> in the grammar, and have no semantic significance.</p>

<p>A Rust program has identical meaning if each whitespace element is replaced
with any other legal whitespace element, such as a single space character.</p>

<h2 id="tokens" class="section-header"><a href="#tokens">3.5 Tokens</a></h2>
<p>Tokens are primitive productions in the grammar defined by regular
(non-recursive) languages. "Simple" tokens are given in <a href="#string-table-productions">string table
production</a> form, and occur in the rest of the
grammar as double-quoted strings. Other tokens have exact rules given.</p>

<h3 id="literals" class="section-header"><a href="#literals">3.5.1 Literals</a></h3>
<p>A literal is an expression consisting of a single token, rather than a sequence
of tokens, that immediately and directly denotes the value it evaluates to,
rather than referring to it by name or some other evaluation rule. A literal is
a form of constant expression, so is evaluated (primarily) at compile time.</p>

<h4 id="examples" class="section-header"><a href="#examples">3.5.1.1 Examples</a></h4>
<h5 id="characters-and-strings" class="section-header"><a href="#characters-and-strings">3.5.1.1.1 Characters and strings</a></h5>
<table>
<thead>
<tr>
<th></th>
<th>Example</th>
<th><code>#</code> sets</th>
<th>Characters</th>
<th>Escapes</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="#character-literals">Character</a></td>
<td><code>'H'</code></td>
<td><code>N/A</code></td>
<td>All Unicode</td>
<td><code>\'</code> &amp; <a href="#byte-escapes">Byte</a> &amp; <a href="#unicode-escapes">Unicode</a></td>
</tr>
<tr>
<td><a href="#string-literals">String</a></td>
<td><code>"hello"</code></td>
<td><code>N/A</code></td>
<td>All Unicode</td>
<td><code>\"</code> &amp; <a href="#byte-escapes">Byte</a> &amp; <a href="#unicode-escapes">Unicode</a></td>
</tr>
<tr>
<td><a href="#raw-string-literals">Raw</a></td>
<td><code>r#"hello"#</code></td>
<td><code>0...</code></td>
<td>All Unicode</td>
<td><code>N/A</code></td>
</tr>
<tr>
<td><a href="#byte-literals">Byte</a></td>
<td><code>b'H'</code></td>
<td><code>N/A</code></td>
<td>All ASCII</td>
<td><code>\'</code> &amp; <a href="#byte-escapes">Byte</a></td>
</tr>
<tr>
<td><a href="#byte-string-literals">Byte string</a></td>
<td><code>b"hello"</code></td>
<td><code>N/A</code></td>
<td>All ASCII</td>
<td><code>\"</code> &amp; <a href="#byte-escapes">Byte</a></td>
</tr>
<tr>
<td><a href="#raw-byte-string-literals">Raw byte string</a></td>
<td><code>br#"hello"#</code></td>
<td><code>0...</code></td>
<td>All ASCII</td>
<td><code>N/A</code></td>
</tr>
</tbody>
</table>

<h5 id="byte-escapes" class="section-header"><a href="#byte-escapes">3.5.1.1.2 Byte escapes</a></h5>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>\x7F</code></td>
<td>8-bit character code (exactly 2 digits)</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>Newline</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Tab</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>Backslash</td>
</tr>
</tbody>
</table>

<h5 id="unicode-escapes" class="section-header"><a href="#unicode-escapes">3.5.1.1.3 Unicode escapes</a></h5>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>\u{7FFF}</code></td>
<td>24-bit Unicode character code (up to 6 digits)</td>
</tr>
</tbody>
</table>

<h5 id="numbers" class="section-header"><a href="#numbers">3.5.1.1.4 Numbers</a></h5>
<table>
<thead>
<tr>
<th><a href="#number-literals">Number literals</a><code>*</code></th>
<th>Example</th>
<th>Exponentiation</th>
<th>Suffixes</th>
</tr>
</thead>

<tbody>
<tr>
<td>Decimal integer</td>
<td><code>98_222</code></td>
<td><code>N/A</code></td>
<td>Integer suffixes</td>
</tr>
<tr>
<td>Hex integer</td>
<td><code>0xff</code></td>
<td><code>N/A</code></td>
<td>Integer suffixes</td>
</tr>
<tr>
<td>Octal integer</td>
<td><code>0o77</code></td>
<td><code>N/A</code></td>
<td>Integer suffixes</td>
</tr>
<tr>
<td>Binary integer</td>
<td><code>0b1111_0000</code></td>
<td><code>N/A</code></td>
<td>Integer suffixes</td>
</tr>
<tr>
<td>Floating-point</td>
<td><code>123.0E+77</code></td>
<td><code>Optional</code></td>
<td>Floating-point suffixes</td>
</tr>
</tbody>
</table>

<p><code>*</code> All number literals allow <code>_</code> as a visual separator: <code>1_234.0E+18f64</code></p>

<h5 id="suffixes" class="section-header"><a href="#suffixes">3.5.1.1.5 Suffixes</a></h5>
<table>
<thead>
<tr>
<th>Integer</th>
<th>Floating-point</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>isize</code>, <code>usize</code></td>
<td><code>f32</code>, <code>f64</code></td>
</tr>
</tbody>
</table>

<h4 id="character-and-string-literals" class="section-header"><a href="#character-and-string-literals">3.5.1.2 Character and string literals</a></h4>
<h5 id="character-literals" class="section-header"><a href="#character-literals">3.5.1.2.1 Character literals</a></h5>
<p>A <em>character literal</em> is a single Unicode character enclosed within two
<code>U+0027</code> (single-quote) characters, with the exception of <code>U+0027</code> itself,
which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p>

<h5 id="string-literals" class="section-header"><a href="#string-literals">3.5.1.2.2 String literals</a></h5>
<p>A <em>string literal</em> is a sequence of any Unicode characters enclosed within two
<code>U+0022</code> (double-quote) characters, with the exception of <code>U+0022</code> itself,
which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p>

<p>Line-break characters are allowed in string literals. Normally they represent
themselves (i.e. no translation), but as a special exception, when a <code>U+005C</code>
character (<code>\</code>) occurs immediately before the newline, the <code>U+005C</code> character,
the newline, and all whitespace at the beginning of the next line are ignored.
Thus <code>a</code> and <code>b</code> are equal:</p>
<span class="rusttest">fn main() {
    let a = "foobar";
    let b = "foo\
             bar";
    
    assert_eq!(a,b);
    
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="string">"foobar"</span>;
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="string">"foo\
         bar"</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>,<span class="ident">b</span>);</pre>

<h5 id="character-escapes" class="section-header"><a href="#character-escapes">3.5.1.2.3 Character escapes</a></h5>
<p>Some additional <em>escapes</em> are available in either character or non-raw string
literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the
following forms:</p>

<ul>
<li>An <em>8-bit code point escape</em> starts with <code>U+0078</code> (<code>x</code>) and is
followed by exactly two <em>hex digits</em>. It denotes the Unicode code point
equal to the provided hex value.</li>
<li>A <em>24-bit code point escape</em> starts with <code>U+0075</code> (<code>u</code>) and is followed
by up to six <em>hex digits</em> surrounded by braces <code>U+007B</code> (<code>{</code>) and <code>U+007D</code>
(<code>}</code>). It denotes the Unicode code point equal to the provided hex value.</li>
<li>A <em>whitespace escape</em> is one of the characters <code>U+006E</code> (<code>n</code>), <code>U+0072</code>
(<code>r</code>), or <code>U+0074</code> (<code>t</code>), denoting the Unicode values <code>U+000A</code> (LF),
<code>U+000D</code> (CR) or <code>U+0009</code> (HT) respectively.</li>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be
escaped in order to denote <em>itself</em>.</li>
</ul>

<h5 id="raw-string-literals" class="section-header"><a href="#raw-string-literals">3.5.1.2.4 Raw string literals</a></h5>
<p>Raw string literals do not process any escapes. They start with the character
<code>U+0072</code> (<code>r</code>), followed by zero or more of the character <code>U+0023</code> (<code>#</code>) and a
<code>U+0022</code> (double-quote) character. The <em>raw string body</em> can contain any sequence
of Unicode characters and is terminated only by another <code>U+0022</code> (double-quote)
character, followed by the same number of <code>U+0023</code> (<code>#</code>) characters that preceded
the opening <code>U+0022</code> (double-quote) character.</p>

<p>All Unicode characters contained in the raw string body represent themselves,
the characters <code>U+0022</code> (double-quote) (except when followed by at least as
many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or
<code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>

<p>Examples for string literals:</p>
<span class="rusttest">fn main() {
    "foo"; r"foo";                     // foo
    "\"foo\""; r#""foo""#;             // "foo"
    
    "foo #\"# bar";
    r##"foo #"# bar"##;                // foo #"# bar
    
    "\x52"; "R"; r"R";                 // R
    "\\x52"; r"\x52";                  // \x52
    
}</span><pre class="rust rust-example-rendered"><span class="string">"foo"</span>; <span class="string">r"foo"</span>;                     <span class="comment">// foo</span>
<span class="string">"\"foo\""</span>; <span class="string">r#""foo""#</span>;             <span class="comment">// "foo"</span>

<span class="string">"foo #\"# bar"</span>;
<span class="string">r##"foo #"# bar"##</span>;                <span class="comment">// foo #"# bar</span>

<span class="string">"\x52"</span>; <span class="string">"R"</span>; <span class="string">r"R"</span>;                 <span class="comment">// R</span>
<span class="string">"\\x52"</span>; <span class="string">r"\x52"</span>;                  <span class="comment">// \x52</span></pre>

<h4 id="byte-and-byte-string-literals" class="section-header"><a href="#byte-and-byte-string-literals">3.5.1.3 Byte and byte string literals</a></h4>
<h5 id="byte-literals" class="section-header"><a href="#byte-literals">3.5.1.3.1 Byte literals</a></h5>
<p>A <em>byte literal</em> is a single ASCII character (in the <code>U+0000</code> to <code>U+007F</code>
range) or a single <em>escape</em> preceded by the characters <code>U+0062</code> (<code>b</code>) and
<code>U+0027</code> (single-quote), and followed by the character <code>U+0027</code>. If the character
<code>U+0027</code> is present within the literal, it must be <em>escaped</em> by a preceding
<code>U+005C</code> (<code>\</code>) character. It is equivalent to a <code>u8</code> unsigned 8-bit integer
<em>number literal</em>.</p>

<h5 id="byte-string-literals" class="section-header"><a href="#byte-string-literals">3.5.1.3.2 Byte string literals</a></h5>
<p>A non-raw <em>byte string literal</em> is a sequence of ASCII characters and <em>escapes</em>,
preceded by the characters <code>U+0062</code> (<code>b</code>) and <code>U+0022</code> (double-quote), and
followed by the character <code>U+0022</code>. If the character <code>U+0022</code> is present within
the literal, it must be <em>escaped</em> by a preceding <code>U+005C</code> (<code>\</code>) character.
Alternatively, a byte string literal can be a <em>raw byte string literal</em>, defined
below. A byte string literal of length <code>n</code> is equivalent to a <code>&amp;'static [u8; n]</code> borrowed fixed-sized array
of unsigned 8-bit integers.</p>

<p>Some additional <em>escapes</em> are available in either byte or non-raw byte string
literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the
following forms:</p>

<ul>
<li>A <em>byte escape</em> escape starts with <code>U+0078</code> (<code>x</code>) and is
followed by exactly two <em>hex digits</em>. It denotes the byte
equal to the provided hex value.</li>
<li>A <em>whitespace escape</em> is one of the characters <code>U+006E</code> (<code>n</code>), <code>U+0072</code>
(<code>r</code>), or <code>U+0074</code> (<code>t</code>), denoting the bytes values <code>0x0A</code> (ASCII LF),
<code>0x0D</code> (ASCII CR) or <code>0x09</code> (ASCII HT) respectively.</li>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be
escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>

<h5 id="raw-byte-string-literals" class="section-header"><a href="#raw-byte-string-literals">3.5.1.3.3 Raw byte string literals</a></h5>
<p>Raw byte string literals do not process any escapes. They start with the
character <code>U+0062</code> (<code>b</code>), followed by <code>U+0072</code> (<code>r</code>), followed by zero or more
of the character <code>U+0023</code> (<code>#</code>), and a <code>U+0022</code> (double-quote) character. The
<em>raw string body</em> can contain any sequence of ASCII characters and is terminated
only by another <code>U+0022</code> (double-quote) character, followed by the same number of
<code>U+0023</code> (<code>#</code>) characters that preceded the opening <code>U+0022</code> (double-quote)
character. A raw byte string literal can not contain any non-ASCII byte.</p>

<p>All characters contained in the raw string body represent their ASCII encoding,
the characters <code>U+0022</code> (double-quote) (except when followed by at least as
many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or
<code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>

<p>Examples for byte string literals:</p>
<span class="rusttest">fn main() {
    b"foo"; br"foo";                     // foo
    b"\"foo\""; br#""foo""#;             // "foo"
    
    b"foo #\"# bar";
    br##"foo #"# bar"##;                 // foo #"# bar
    
    b"\x52"; b"R"; br"R";                // R
    b"\\x52"; br"\x52";                  // \x52
    
}</span><pre class="rust rust-example-rendered"><span class="string">b"foo"</span>; <span class="string">br"foo"</span>;                     <span class="comment">// foo</span>
<span class="string">b"\"foo\""</span>; <span class="string">br#""foo""#</span>;             <span class="comment">// "foo"</span>

<span class="string">b"foo #\"# bar"</span>;
<span class="string">br##"foo #"# bar"##</span>;                 <span class="comment">// foo #"# bar</span>

<span class="string">b"\x52"</span>; <span class="string">b"R"</span>; <span class="string">br"R"</span>;                <span class="comment">// R</span>
<span class="string">b"\\x52"</span>; <span class="string">br"\x52"</span>;                  <span class="comment">// \x52</span></pre>

<h4 id="number-literals" class="section-header"><a href="#number-literals">3.5.1.4 Number literals</a></h4>
<p>A <em>number literal</em> is either an <em>integer literal</em> or a <em>floating-point
literal</em>. The grammar for recognizing the two kinds of literals is mixed.</p>

<h5 id="integer-literals" class="section-header"><a href="#integer-literals">3.5.1.4.1 Integer literals</a></h5>
<p>An <em>integer literal</em> has one of four forms:</p>

<ul>
<li>A <em>decimal literal</em> starts with a <em>decimal digit</em> and continues with any
mixture of <em>decimal digits</em> and <em>underscores</em>.</li>
<li>A <em>hex literal</em> starts with the character sequence <code>U+0030</code> <code>U+0078</code>
(<code>0x</code>) and continues as any mixture of hex digits and underscores.</li>
<li>An <em>octal literal</em> starts with the character sequence <code>U+0030</code> <code>U+006F</code>
(<code>0o</code>) and continues as any mixture of octal digits and underscores.</li>
<li>A <em>binary literal</em> starts with the character sequence <code>U+0030</code> <code>U+0062</code>
(<code>0b</code>) and continues as any mixture of binary digits and underscores.</li>
</ul>

<p>Like any literal, an integer literal may be followed (immediately,
without any spaces) by an <em>integer suffix</em>, which forcibly sets the
type of the literal. The integer suffix must be the name of one of the
integral types: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>,
<code>isize</code>, or <code>usize</code>.</p>

<p>The type of an <em>unsuffixed</em> integer literal is determined by type inference:</p>

<ul>
<li><p>If an integer type can be <em>uniquely</em> determined from the surrounding
program context, the unsuffixed integer literal has that type.</p></li>
<li><p>If the program context under-constrains the type, it defaults to the
signed 32-bit integer <code>i32</code>.</p></li>
<li><p>If the program context over-constrains the type, it is considered a
static type error.</p></li>
</ul>

<p>Examples of integer literals of various forms:</p>
<span class="rusttest">fn main() {
    123i32;                            // type i32
    123u32;                            // type u32
    123_u32;                           // type u32
    0xff_u8;                           // type u8
    0o70_i16;                          // type i16
    0b1111_1111_1001_0000_i32;         // type i32
    0usize;                            // type usize
    
}</span><pre class="rust rust-example-rendered"><span class="number">123i32</span>;                            <span class="comment">// type i32</span>
<span class="number">123u32</span>;                            <span class="comment">// type u32</span>
<span class="number">123_u32</span>;                           <span class="comment">// type u32</span>
<span class="number">0xff_u8</span>;                           <span class="comment">// type u8</span>
<span class="number">0o70_i16</span>;                          <span class="comment">// type i16</span>
<span class="number">0b1111_1111_1001_0000_i32</span>;         <span class="comment">// type i32</span>
<span class="number">0usize</span>;                            <span class="comment">// type usize</span></pre>

<h5 id="floating-point-literals" class="section-header"><a href="#floating-point-literals">3.5.1.4.2 Floating-point literals</a></h5>
<p>A <em>floating-point literal</em> has one of two forms:</p>

<ul>
<li>A <em>decimal literal</em> followed by a period character <code>U+002E</code> (<code>.</code>). This is
optionally followed by another decimal literal, with an optional <em>exponent</em>.</li>
<li>A single <em>decimal literal</em> followed by an <em>exponent</em>.</li>
</ul>

<p>Like integer literals, a floating-point literal may be followed by a
suffix, so long as the pre-suffix part does not end with <code>U+002E</code> (<code>.</code>).
The suffix forcibly sets the type of the literal. There are two valid
<em>floating-point suffixes</em>, <code>f32</code> and <code>f64</code> (the 32-bit and 64-bit floating point
types), which explicitly determine the type of the literal.</p>

<p>The type of an <em>unsuffixed</em> floating-point literal is determined by
type inference:</p>

<ul>
<li><p>If a floating-point type can be <em>uniquely</em> determined from the
surrounding program context, the unsuffixed floating-point literal
has that type.</p></li>
<li><p>If the program context under-constrains the type, it defaults to <code>f64</code>.</p></li>
<li><p>If the program context over-constrains the type, it is considered a
static type error.</p></li>
</ul>

<p>Examples of floating-point literals of various forms:</p>
<span class="rusttest">fn main() {
    123.0f64;        // type f64
    0.1f64;          // type f64
    0.1f32;          // type f32
    12E+99_f64;      // type f64
    let x: f64 = 2.; // type f64
    
}</span><pre class="rust rust-example-rendered"><span class="number">123.0f64</span>;        <span class="comment">// type f64</span>
<span class="number">0.1f64</span>;          <span class="comment">// type f64</span>
<span class="number">0.1f32</span>;          <span class="comment">// type f32</span>
<span class="number">12E+99_f64</span>;      <span class="comment">// type f64</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">f64</span> <span class="op">=</span> <span class="number">2.</span>; <span class="comment">// type f64</span></pre>

<p>This last example is different because it is not possible to use the suffix
syntax with a floating point literal ending in a period. <code>2.f64</code> would attempt
to call a method named <code>f64</code> on <code>2</code>.</p>

<p>The representation semantics of floating-point numbers are described in
<a href="#machine-types">"Machine Types"</a>.</p>

<h4 id="boolean-literals" class="section-header"><a href="#boolean-literals">3.5.1.5 Boolean literals</a></h4>
<p>The two values of the boolean type are written <code>true</code> and <code>false</code>.</p>

<h3 id="symbols" class="section-header"><a href="#symbols">3.5.2 Symbols</a></h3>
<p>Symbols are a general class of printable <a href="#tokens">token</a> that play structural
roles in a variety of grammar productions. They are catalogued here for
completeness as the set of remaining miscellaneous printable tokens that do not
otherwise appear as <a href="#unary-operator-expressions">unary operators</a>, <a href="#binary-operator-expressions">binary
operators</a>, or <a href="http://doc.rust-lang.org/grammar.html#keywords">keywords</a>.</p>

<h2 id="paths" class="section-header"><a href="#paths">3.6 Paths</a></h2>
<p>A <em>path</em> is a sequence of one or more path components <em>logically</em> separated by
a namespace qualifier (<code>::</code>). If a path consists of only one component, it may
refer to either an <a href="#items">item</a> or a <a href="#variables">variable</a> in a local control
scope. If a path has multiple components, it refers to an item.</p>

<p>Every item has a <em>canonical path</em> within its crate, but the path naming an item
is only meaningful within a given crate. There is no global namespace across
crates; an item's canonical path merely identifies it within the crate.</p>

<p>Two examples of simple paths consisting of only identifier components:</p>
<span class="rusttest">fn main() {
    x;
    x::y::z;
    
}</span><pre class="rust rust-example-rendered"><span class="ident">x</span>;
<span class="ident">x</span>::<span class="ident">y</span>::<span class="ident">z</span>;</pre>

<p>Path components are usually <a href="#identifiers">identifiers</a>, but they may
also include angle-bracket-enclosed lists of type arguments. In
<a href="#expressions">expression</a> context, the type argument list is given
after a <code>::</code> namespace qualifier in order to disambiguate it from a
relational expression involving the less-than symbol (<code>&lt;</code>). In type
expression context, the final namespace qualifier is omitted.</p>

<p>Two examples of paths with type arguments:</p>
<span class="rusttest">fn main() {
    struct HashMap&lt;K, V&gt;(K,V);
    fn f() {
    fn id&lt;T&gt;(t: T) -&gt; T { t }
    type T = HashMap&lt;i32,String&gt;; // Type arguments used in a type expression
    let x  = id::&lt;i32&gt;(10);       // Type arguments used in a call expression
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">type</span> <span class="ident">T</span> <span class="op">=</span> <span class="ident">HashMap</span><span class="op">&lt;</span><span class="ident">i32</span>,<span class="ident">String</span><span class="op">&gt;</span>; <span class="comment">// Type arguments used in a type expression</span>
<span class="kw">let</span> <span class="ident">x</span>  <span class="op">=</span> <span class="ident">id</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>(<span class="number">10</span>);       <span class="comment">// Type arguments used in a call expression</span></pre>

<p>Paths can be denoted with various leading qualifiers to change the meaning of
how it is resolved:</p>

<ul>
<li>Paths starting with <code>::</code> are considered to be global paths where the
components of the path start being resolved from the crate root. Each
identifier in the path must resolve to an item.</li>
</ul>
<span class="rusttest">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        ::a::foo(); // call a's foo function
    }
}
fn main() {}
</span><pre class="rust rust-example-rendered"><span class="kw">mod</span> <span class="ident">a</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">foo</span>() {}
}
<span class="kw">mod</span> <span class="ident">b</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">foo</span>() {
        ::<span class="ident">a</span>::<span class="ident">foo</span>(); <span class="comment">// call a's foo function</span>
    }
}</pre>

<ul>
<li>Paths starting with the keyword <code>super</code> begin resolution relative to the
parent module. Each further identifier must resolve to an item.</li>
</ul>
<span class="rusttest">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        super::a::foo(); // call a's foo function
    }
}
fn main() {}
</span><pre class="rust rust-example-rendered"><span class="kw">mod</span> <span class="ident">a</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">foo</span>() {}
}
<span class="kw">mod</span> <span class="ident">b</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">foo</span>() {
        <span class="ident">super</span>::<span class="ident">a</span>::<span class="ident">foo</span>(); <span class="comment">// call a's foo function</span>
    }
}</pre>

<ul>
<li>Paths starting with the keyword <code>self</code> begin resolution relative to the
current module. Each further identifier must resolve to an item.</li>
</ul>
<span class="rusttest">fn foo() {}
fn bar() {
    self::foo();
}
fn main() {}
</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">foo</span>() {}
<span class="kw">fn</span> <span class="ident">bar</span>() {
    <span class="self">self</span>::<span class="ident">foo</span>();
}</pre>

<h1 id="syntax-extensions" class="section-header"><a href="#syntax-extensions">4 Syntax extensions</a></h1>
<p>A number of minor features of Rust are not central enough to have their own
syntax, and yet are not implementable as functions. Instead, they are given
names, and invoked through a consistent syntax: <code>some_extension!(...)</code>.</p>

<p>Users of <code>rustc</code> can define new syntax extensions in two ways:</p>

<ul>
<li><p><a href="http://doc.rust-lang.org/book/compiler-plugins.html">Compiler plugins</a> can include arbitrary Rust code that
manipulates syntax trees at compile time. Note that the interface
for compiler plugins is considered highly unstable.</p></li>
<li><p><a href="http://doc.rust-lang.org/book/macros.html">Macros</a> define new syntax in a higher-level,
declarative way.</p></li>
</ul>

<h2 id="macros" class="section-header"><a href="#macros">4.1 Macros</a></h2>
<p><code>macro_rules</code> allows users to define syntax extension in a declarative way.  We
call such extensions "macros by example" or simply "macros" — to be distinguished
from the "procedural macros" defined in <a href="http://doc.rust-lang.org/book/compiler-plugins.html">compiler plugins</a>.</p>

<p>Currently, macros can expand to expressions, statements, items, or patterns.</p>

<p>(A <code>sep_token</code> is any token other than <code>*</code> and <code>+</code>. A <code>non_special_token</code> is
any token other than a delimiter or <code>$</code>.)</p>

<p>The macro expander looks up macro invocations by name, and tries each macro
rule in turn. It transcribes the first successful match. Matching and
transcription are closely related to each other, and we will describe them
together.</p>

<h3 id="macro-by-example" class="section-header"><a href="#macro-by-example">4.1.1 Macro By Example</a></h3>
<p>The macro expander matches and transcribes every token that does not begin with
a <code>$</code> literally, including delimiters. For parsing reasons, delimiters must be
balanced, but they are otherwise not special.</p>

<p>In the matcher, <code>$</code> <em>name</em> <code>:</code> <em>designator</em> matches the nonterminal in the Rust
syntax named by <em>designator</em>. Valid designators are <code>item</code>, <code>block</code>, <code>stmt</code>,
<code>pat</code>, <code>expr</code>, <code>ty</code> (type), <code>ident</code>, <code>path</code>, <code>tt</code> (either side of the <code>=&gt;</code>
in macro rules), and <code>meta</code> (contents of an attribute). In the transcriber, the
designator is already known, and so only the name of a matched nonterminal comes
after the dollar sign.</p>

<p>In both the matcher and transcriber, the Kleene star-like operator indicates
repetition. The Kleene star operator consists of <code>$</code> and parentheses, optionally
followed by a separator token, followed by <code>*</code> or <code>+</code>. <code>*</code> means zero or more
repetitions, <code>+</code> means at least one repetition. The parentheses are not matched or
transcribed. On the matcher side, a name is bound to <em>all</em> of the names it
matches, in a structure that mimics the structure of the repetition encountered
on a successful match. The job of the transcriber is to sort that structure
out.</p>

<p>The rules for transcription of these repetitions are called "Macro By Example".
Essentially, one "layer" of repetition is discharged at a time, and all of them
must be discharged by the time a name is transcribed. Therefore, <code>( $( $i:ident ),* ) =&gt; ( $i )</code> is an invalid macro, but <code>( $( $i:ident ),* ) =&gt; ( $( $i:ident ),* )</code> is acceptable (if trivial).</p>

<p>When Macro By Example encounters a repetition, it examines all of the <code>$</code>
<em>name</em> s that occur in its body. At the "current layer", they all must repeat
the same number of times, so <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; ( $( ($i,$j) ),* )</code> is valid if given the argument <code>(a,b,c ; d,e,f)</code>, but not
<code>(a,b,c ; d,e)</code>. The repetition walks through the choices at that layer in
lockstep, so the former input transcribes to <code>(a,d), (b,e), (c,f)</code>.</p>

<p>Nested repetitions are allowed.</p>

<h3 id="parsing-limitations" class="section-header"><a href="#parsing-limitations">4.1.2 Parsing limitations</a></h3>
<p>The parser used by the macro system is reasonably powerful, but the parsing of
Rust syntax is restricted in two ways:</p>

<ol>
<li>Macro definitions are required to include suitable separators after parsing
expressions and other bits of the Rust grammar. This implies that
a macro definition like <code>$i:expr [ , ]</code> is not legal, because <code>[</code> could be part
of an expression. A macro definition like <code>$i:expr,</code> or <code>$i:expr;</code> would be legal,
however, because <code>,</code> and <code>;</code> are legal separators. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md">RFC 550</a> for more information.</li>
<li>The parser must have eliminated all ambiguity by the time it reaches a <code>$</code>
<em>name</em> <code>:</code> <em>designator</em>. This requirement most often affects name-designator
pairs when they occur at the beginning of, or immediately after, a <code>$(...)*</code>;
requiring a distinctive token in front can solve the problem.</li>
</ol>

<h1 id="crates-and-source-files" class="section-header"><a href="#crates-and-source-files">5 Crates and source files</a></h1>
<p>Although Rust, like any other language, can be implemented by an interpreter as
well as a compiler, the only existing implementation is a compiler —
from now on referred to as <em>the</em> Rust compiler — and the language has
always been designed to be compiled. For these reasons, this section assumes a
compiler.</p>

<p>Rust's semantics obey a <em>phase distinction</em> between compile-time and
run-time.<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup> Semantic rules that have a <em>static
interpretation</em> govern the success or failure of compilation, while
semantic rules
that have a <em>dynamic interpretation</em> govern the behavior of the program at
run-time.</p>

<p>The compilation model centers on artifacts called <em>crates</em>. Each compilation
processes a single crate in source form, and if successful, produces a single
crate in binary form: either an executable or some sort of
library.<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup></p>

<p>A <em>crate</em> is a unit of compilation and linking, as well as versioning,
distribution and runtime loading. A crate contains a <em>tree</em> of nested
<a href="#modules">module</a> scopes. The top level of this tree is a module that is
anonymous (from the point of view of paths within the module) and any item
within a crate has a canonical <a href="#paths">module path</a> denoting its location
within the crate's module tree.</p>

<p>The Rust compiler is always invoked with a single source file as input, and
always produces a single output crate. The processing of that source file may
result in other source files being loaded as modules. Source files have the
extension <code>.rs</code>.</p>

<p>A Rust source file describes a module, the name and location of which —
in the module tree of the current crate — are defined from outside the
source file: either by an explicit <code>mod_item</code> in a referencing source file, or
by the name of the crate itself. Every source file is a module, but not every
module needs its own source file: <a href="#modules">module definitions</a> can be nested
within one file.</p>

<p>Each source file contains a sequence of zero or more <code>item</code> definitions, and
may optionally begin with any number of <a href="#items-and-attributes">attributes</a>
that apply to the containing module, most of which influence the behavior of
the compiler. The anonymous crate module can have additional attributes that
apply to the crate as a whole.</p>
<span class="rusttest">fn main() {
    // Specify the crate name.
    #![crate_name = "projx"]
    
    // Specify the type of output artifact.
    #![crate_type = "lib"]
    
    // Turn on a warning.
    // This can be done in any module, not just the anonymous crate module.
    #![warn(non_camel_case_types)]
    
}</span><pre class="rust rust-example-rendered"><span class="comment">// Specify the crate name.</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">crate_name</span> <span class="op">=</span> <span class="string">"projx"</span>]</span>

<span class="comment">// Specify the type of output artifact.</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">crate_type</span> <span class="op">=</span> <span class="string">"lib"</span>]</span>

<span class="comment">// Turn on a warning.</span>
<span class="comment">// This can be done in any module, not just the anonymous crate module.</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">warn</span>(<span class="ident">non_camel_case_types</span>)]</span></pre>

<p>A crate that contains a <code>main</code> function can be compiled to an executable. If a
<code>main</code> function is present, its return type must be <a href="#tuple-types"><code>unit</code></a>
and it must take no arguments.</p>

<h1 id="items-and-attributes" class="section-header"><a href="#items-and-attributes">6 Items and attributes</a></h1>
<p>Crates contain <a href="#items">items</a>, each of which may have some number of
<a href="#attributes">attributes</a> attached to it.</p>

<h2 id="items" class="section-header"><a href="#items">6.1 Items</a></h2>
<p>An <em>item</em> is a component of a crate. Items are organized within a crate by a
nested set of <a href="#modules">modules</a>. Every crate has a single "outermost"
anonymous module; all further items within the crate have <a href="#paths">paths</a>
within the module tree of the crate.</p>

<p>Items are entirely determined at compile-time, generally remain fixed during
execution, and may reside in read-only memory.</p>

<p>There are several kinds of item:</p>

<ul>
<li><a href="#extern-crate-declarations"><code>extern crate</code> declarations</a></li>
<li><a href="#use-declarations"><code>use</code> declarations</a></li>
<li><a href="#modules">modules</a></li>
<li><a href="#functions">functions</a></li>
<li><a href="http://doc.rust-lang.org/grammar.html#type-definitions">type definitions</a></li>
<li><a href="#structures">structures</a></li>
<li><a href="#enumerations">enumerations</a></li>
<li><a href="#constant-items">constant items</a></li>
<li><a href="#static-items">static items</a></li>
<li><a href="#traits">traits</a></li>
<li><a href="#implementations">implementations</a></li>
</ul>

<p>Some items form an implicit scope for the declaration of sub-items. In other
words, within a function or module, declarations of items can (in many cases)
be mixed with the statements, control blocks, and similar artifacts that
otherwise compose the item body. The meaning of these scoped items is the same
as if the item was declared outside the scope — it is still a static item
— except that the item's <em>path name</em> within the module namespace is
qualified by the name of the enclosing item, or is private to the enclosing
item (in the case of functions). The grammar specifies the exact locations in
which sub-item declarations may appear.</p>

<h3 id="type-parameters" class="section-header"><a href="#type-parameters">6.1.1 Type Parameters</a></h3>
<p>All items except modules, constants and statics may be <em>parameterized</em> by type.
Type parameters are given as a comma-separated list of identifiers enclosed in
angle brackets (<code>&lt;...&gt;</code>), after the name of the item and before its definition.
The type parameters of an item are considered "part of the name", not part of
the type of the item. A referencing <a href="#paths">path</a> must (in principle) provide
type arguments as a list of comma-separated types enclosed within angle
brackets, in order to refer to the type-parameterized item. In practice, the
type-inference system can usually infer such argument types from context. There
are no general type-parametric types, only type-parametric items. That is, Rust
has no notion of type abstraction: there are no higher-ranked (or "forall") types
abstracted over other types, though higher-ranked types do exist for lifetimes.</p>

<h3 id="modules" class="section-header"><a href="#modules">6.1.2 Modules</a></h3>
<p>A module is a container for zero or more <a href="#items">items</a>.</p>

<p>A <em>module item</em> is a module, surrounded in braces, named, and prefixed with the
keyword <code>mod</code>. A module item introduces a new, named module into the tree of
modules making up a crate. Modules can nest arbitrarily.</p>

<p>An example of a module:</p>
<span class="rusttest">fn main() {
    mod math {
        type Complex = (f64, f64);
        fn sin(f: f64) -&gt; f64 {
            /* ... */
    panic!();
        }
        fn cos(f: f64) -&gt; f64 {
            /* ... */
    panic!();
        }
        fn tan(f: f64) -&gt; f64 {
            /* ... */
    panic!();
        }
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">mod</span> <span class="ident">math</span> {
    <span class="kw">type</span> <span class="ident">Complex</span> <span class="op">=</span> (<span class="ident">f64</span>, <span class="ident">f64</span>);
    <span class="kw">fn</span> <span class="ident">sin</span>(<span class="ident">f</span>: <span class="ident">f64</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
        <span class="comment">/* ... */</span>
    }
    <span class="kw">fn</span> <span class="ident">cos</span>(<span class="ident">f</span>: <span class="ident">f64</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
        <span class="comment">/* ... */</span>
    }
    <span class="kw">fn</span> <span class="ident">tan</span>(<span class="ident">f</span>: <span class="ident">f64</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
        <span class="comment">/* ... */</span>
    }
}</pre>

<p>Modules and types share the same namespace. Declaring a named type with
the same name as a module in scope is forbidden: that is, a type definition,
trait, struct, enumeration, or type parameter can't shadow the name of a module
in scope, or vice versa.</p>

<p>A module without a body is loaded from an external file, by default with the
same name as the module, plus the <code>.rs</code> extension. When a nested submodule is
loaded from an external file, it is loaded from a subdirectory path that
mirrors the module hierarchy.</p>
<span class="rusttest">fn main() {
    // Load the `vec` module from `vec.rs`
    mod vec;
    
    mod thread {
        // Load the `local_data` module from `thread/local_data.rs`
        // or `thread/local_data/mod.rs`.
        mod local_data;
    }
    
}</span><pre class="rust rust-example-rendered"><span class="comment">// Load the `vec` module from `vec.rs`</span>
<span class="kw">mod</span> <span class="ident">vec</span>;

<span class="kw">mod</span> <span class="ident">thread</span> {
    <span class="comment">// Load the `local_data` module from `thread/local_data.rs`</span>
    <span class="comment">// or `thread/local_data/mod.rs`.</span>
    <span class="kw">mod</span> <span class="ident">local_data</span>;
}</pre>

<p>The directories and files used for loading external file modules can be
influenced with the <code>path</code> attribute.</p>
<span class="rusttest">fn main() {
    #[path = "thread_files"]
    mod thread {
        // Load the `local_data` module from `thread_files/tls.rs`
        #[path = "tls.rs"]
        mod local_data;
    }
    
}</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">path</span> <span class="op">=</span> <span class="string">"thread_files"</span>]</span>
<span class="kw">mod</span> <span class="ident">thread</span> {
    <span class="comment">// Load the `local_data` module from `thread_files/tls.rs`</span>
    <span class="attribute">#[<span class="ident">path</span> <span class="op">=</span> <span class="string">"tls.rs"</span>]</span>
    <span class="kw">mod</span> <span class="ident">local_data</span>;
}</pre>

<h4 id="extern-crate-declarations" class="section-header"><a href="#extern-crate-declarations">6.1.2.1 Extern crate declarations</a></h4>
<p>An <em><code>extern crate</code> declaration</em> specifies a dependency on an external crate.
The external crate is then bound into the declaring scope as the <code>ident</code>
provided in the <code>extern_crate_decl</code>.</p>

<p>The external crate is resolved to a specific <code>soname</code> at compile time, and a
runtime linkage requirement to that <code>soname</code> is passed to the linker for
loading at runtime. The <code>soname</code> is resolved at compile time by scanning the
compiler's library path and matching the optional <code>crateid</code> provided against
the <code>crateid</code> attributes that were declared on the external crate when it was
compiled. If no <code>crateid</code> is provided, a default <code>name</code> attribute is assumed,
equal to the <code>ident</code> given in the <code>extern_crate_decl</code>.</p>

<p>Three examples of <code>extern crate</code> declarations:</p>
<span class="rusttest">fn main() {
    extern crate pcre;
    
    extern crate std; // equivalent to: extern crate std as std;
    
    extern crate std as ruststd; // linking to 'std' under another name
    
}</span><pre class="rust rust-example-rendered"><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">pcre</span>;

<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">std</span>; <span class="comment">// equivalent to: extern crate std as std;</span>

<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">std</span> <span class="kw">as</span> <span class="ident">ruststd</span>; <span class="comment">// linking to 'std' under another name</span></pre>

<h4 id="use-declarations" class="section-header"><a href="#use-declarations">6.1.2.2 Use declarations</a></h4>
<p>A <em>use declaration</em> creates one or more local name bindings synonymous with
some other <a href="#paths">path</a>. Usually a <code>use</code> declaration is used to shorten the
path required to refer to a module item. These declarations may appear at the
top of <a href="#modules">modules</a> and <a href="http://doc.rust-lang.org/grammar.html#block-expressions">blocks</a>.</p>

<blockquote>
<p><strong>Note</strong>: Unlike in many languages,
<code>use</code> declarations in Rust do <em>not</em> declare linkage dependency with external crates.
Rather, <a href="#extern-crate-declarations"><code>extern crate</code> declarations</a> declare linkage dependencies.</p>
</blockquote>

<p>Use declarations support a number of convenient shortcuts:</p>

<ul>
<li>Rebinding the target name as a new local name, using the syntax <code>use p::q::r as x;</code></li>
<li>Simultaneously binding a list of paths differing only in their final element,
using the glob-like brace syntax <code>use a::b::{c,d,e,f};</code></li>
<li>Binding all paths matching a given prefix, using the asterisk wildcard syntax
<code>use a::b::*;</code></li>
<li>Simultaneously binding a list of paths differing only in their final element
and their immediate parent module, using the <code>self</code> keyword, such as
<code>use a::b::{self, c, d};</code></li>
</ul>

<p>An example of <code>use</code> declarations:</p>
<span class="rusttest">use std::option::Option::{Some, None};
use std::collections::hash_map::{self, HashMap};

fn foo&lt;T&gt;(_: T){}
fn bar(map1: HashMap&lt;String, usize&gt;, map2: hash_map::HashMap&lt;String, usize&gt;){}

fn main() {
    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),
    // std::option::Option::None]);'
    foo(vec![Some(1.0f64), None]);

    // Both `hash_map` and `HashMap` are in scope.
    let map1 = HashMap::new();
    let map2 = hash_map::HashMap::new();
    bar(map1, map2);
}
</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">option</span>::<span class="prelude-ty">Option</span>::{<span class="prelude-val">Some</span>, <span class="prelude-val">None</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">hash_map</span>::{<span class="self">self</span>, <span class="ident">HashMap</span>};

<span class="kw">fn</span> <span class="ident">foo</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(_: <span class="ident">T</span>){}
<span class="kw">fn</span> <span class="ident">bar</span>(<span class="ident">map1</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="ident">String</span>, <span class="ident">usize</span><span class="op">&gt;</span>, <span class="ident">map2</span>: <span class="ident">hash_map</span>::<span class="ident">HashMap</span><span class="op">&lt;</span><span class="ident">String</span>, <span class="ident">usize</span><span class="op">&gt;</span>){}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),</span>
    <span class="comment">// std::option::Option::None]);'</span>
    <span class="ident">foo</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Some</span>(<span class="number">1.0f64</span>), <span class="prelude-val">None</span>]);

    <span class="comment">// Both `hash_map` and `HashMap` are in scope.</span>
    <span class="kw">let</span> <span class="ident">map1</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
    <span class="kw">let</span> <span class="ident">map2</span> <span class="op">=</span> <span class="ident">hash_map</span>::<span class="ident">HashMap</span>::<span class="ident">new</span>();
    <span class="ident">bar</span>(<span class="ident">map1</span>, <span class="ident">map2</span>);
}</pre>

<p>Like items, <code>use</code> declarations are private to the containing module, by
default. Also like items, a <code>use</code> declaration can be public, if qualified by
the <code>pub</code> keyword. Such a <code>use</code> declaration serves to <em>re-export</em> a name. A
public <code>use</code> declaration can therefore <em>redirect</em> some public name to a
different target definition: even a definition with a private canonical path,
inside a different module. If a sequence of such redirections form a cycle or
cannot be resolved unambiguously, they represent a compile-time error.</p>

<p>An example of re-exporting:</p>
<span class="rusttest">fn main() { }
mod quux {
    pub use quux::foo::{bar, baz};

    pub mod foo {
        pub fn bar() { }
        pub fn baz() { }
    }
}
</span><pre class="rust rust-example-rendered"><span class="kw">mod</span> <span class="ident">quux</span> {
    <span class="kw">pub</span> <span class="kw">use</span> <span class="ident">quux</span>::<span class="ident">foo</span>::{<span class="ident">bar</span>, <span class="ident">baz</span>};

    <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">foo</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bar</span>() { }
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">baz</span>() { }
    }
}</pre>

<p>In this example, the module <code>quux</code> re-exports two public names defined in
<code>foo</code>.</p>

<p>Also note that the paths contained in <code>use</code> items are relative to the crate
root. So, in the previous example, the <code>use</code> refers to <code>quux::foo::{bar, baz}</code>, and not simply to <code>foo::{bar, baz}</code>. This also means that top-level
module declarations should be at the crate root if direct usage of the declared
modules within <code>use</code> items is desired. It is also possible to use <code>self</code> and
<code>super</code> at the beginning of a <code>use</code> item to refer to the current and direct
parent modules respectively. All rules regarding accessing declared modules in
<code>use</code> declarations apply to both module declarations and <code>extern crate</code>
declarations.</p>

<p>An example of what will and will not work for <code>use</code> items:</p>
<span class="rusttest">#![allow(unused_imports)]
use foo::baz::foobaz;    // good: foo is at the root of the crate

mod foo {

    mod example {
        pub mod iter {}
    }

    use foo::example::iter; // good: foo is at crate root
//  use example::iter;      // bad:  core is not at the crate root
    use self::baz::foobaz;  // good: self refers to module 'foo'
    use foo::bar::foobar;   // good: foo is at crate root

    pub mod bar {
        pub fn foobar() { }
    }

    pub mod baz {
        use super::bar::foobar; // good: super refers to module 'foo'
        pub fn foobaz() { }
    }
}

fn main() {}
</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">foo</span>::<span class="ident">baz</span>::<span class="ident">foobaz</span>;    <span class="comment">// good: foo is at the root of the crate</span>

<span class="kw">mod</span> <span class="ident">foo</span> {

    <span class="kw">mod</span> <span class="ident">example</span> {
        <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">iter</span> {}
    }

    <span class="kw">use</span> <span class="ident">foo</span>::<span class="ident">example</span>::<span class="ident">iter</span>; <span class="comment">// good: foo is at crate root</span>
<span class="comment">//  use example::iter;      // bad:  core is not at the crate root</span>
    <span class="kw">use</span> <span class="self">self</span>::<span class="ident">baz</span>::<span class="ident">foobaz</span>;  <span class="comment">// good: self refers to module 'foo'</span>
    <span class="kw">use</span> <span class="ident">foo</span>::<span class="ident">bar</span>::<span class="ident">foobar</span>;   <span class="comment">// good: foo is at crate root</span>

    <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">bar</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">foobar</span>() { }
    }

    <span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">baz</span> {
        <span class="kw">use</span> <span class="ident">super</span>::<span class="ident">bar</span>::<span class="ident">foobar</span>; <span class="comment">// good: super refers to module 'foo'</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">foobaz</span>() { }
    }
}

<span class="kw">fn</span> <span class="ident">main</span>() {}</pre>

<h3 id="functions" class="section-header"><a href="#functions">6.1.3 Functions</a></h3>
<p>A <em>function item</em> defines a sequence of <a href="#statements">statements</a> and an
optional final <a href="#expressions">expression</a>, along with a name and a set of
parameters. Functions are declared with the keyword <code>fn</code>. Functions declare a
set of <em>input</em> <a href="#variables"><em>variables</em></a> as parameters, through which the caller
passes arguments into the function, and the <em>output</em> <a href="#types"><em>type</em></a>
of the value the function will return to its caller on completion.</p>

<p>A function may also be copied into a first-class <em>value</em>, in which case the
value has the corresponding <a href="#function-types"><em>function type</em></a>, and can be used
otherwise exactly as a function item (with a minor additional cost of calling
the function indirectly).</p>

<p>Every control path in a function logically ends with a <code>return</code> expression or a
diverging expression. If the outermost block of a function has a
value-producing expression in its final-expression position, that expression is
interpreted as an implicit <code>return</code> expression applied to the final-expression.</p>

<p>An example of a function:</p>
<span class="rusttest">fn main() {
    fn add(x: i32, y: i32) -&gt; i32 {
        return x + y;
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">add</span>(<span class="ident">x</span>: <span class="ident">i32</span>, <span class="ident">y</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="kw">return</span> <span class="ident">x</span> <span class="op">+</span> <span class="ident">y</span>;
}</pre>

<p>As with <code>let</code> bindings, function arguments are irrefutable patterns, so any
pattern that is valid in a let binding is also valid as an argument.</p>
<span class="rusttest">fn main() {
    fn first((value, _): (i32, i32)) -&gt; i32 { value }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">first</span>((<span class="ident">value</span>, _): (<span class="ident">i32</span>, <span class="ident">i32</span>)) <span class="op">-&gt;</span> <span class="ident">i32</span> { <span class="ident">value</span> }</pre>

<h4 id="generic-functions" class="section-header"><a href="#generic-functions">6.1.3.1 Generic functions</a></h4>
<p>A <em>generic function</em> allows one or more <em>parameterized types</em> to appear in its
signature. Each type parameter must be explicitly declared, in an
angle-bracket-enclosed, comma-separated list following the function name.</p>
<span class="rusttest">fn main() {
    // foo is generic over A and B
    
    fn foo&lt;A, B&gt;(x: A, y: B) {
    
}</span><pre class="rust rust-example-rendered"><span class="comment">// foo is generic over A and B</span>

<span class="kw">fn</span> <span class="ident">foo</span><span class="op">&lt;</span><span class="ident">A</span>, <span class="ident">B</span><span class="op">&gt;</span>(<span class="ident">x</span>: <span class="ident">A</span>, <span class="ident">y</span>: <span class="ident">B</span>) {</pre>

<p>Inside the function signature and body, the name of the type parameter can be
used as a type name. <a href="#traits">Trait</a> bounds can be specified for type parameters
to allow methods with that trait to be called on values of that type. This is
specified using the <code>where</code> syntax:</p>
<span class="rusttest">fn main() {
    fn foo&lt;T&gt;(x: T) where T: Debug {
    
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">foo</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">x</span>: <span class="ident">T</span>) <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">Debug</span> {</pre>

<p>When a generic function is referenced, its type is instantiated based on the
context of the reference. For example, calling the <code>foo</code> function here:</p>
<span class="rusttest">fn main() {
    use std::fmt::Debug;
    
    fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
        // details elided
    ()
    }
    
    foo(&amp;[1, 2]);
    
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fmt</span>::<span class="ident">Debug</span>;

<span class="kw">fn</span> <span class="ident">foo</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="ident">T</span>]) <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">Debug</span> {
    <span class="comment">// details elided</span>
}

<span class="ident">foo</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>]);</pre>

<p>will instantiate type parameter <code>T</code> with <code>i32</code>.</p>

<p>The type parameters can also be explicitly supplied in a trailing
<a href="#paths">path</a> component after the function name. This might be necessary if
there is not sufficient context to determine the type parameters. For example,
<code>mem::size_of::&lt;u32&gt;() == 4</code>.</p>

<h4 id="unsafety" class="section-header"><a href="#unsafety">6.1.3.2 Unsafety</a></h4>
<p>Unsafe operations are those that potentially violate the memory-safety
guarantees of Rust's static semantics.</p>

<p>The following language level features cannot be used in the safe subset of
Rust:</p>

<ul>
<li>Dereferencing a <a href="#pointer-types">raw pointer</a>.</li>
<li>Reading or writing a <a href="#mutable-statics">mutable static variable</a>.</li>
<li>Calling an unsafe function (including an intrinsic or foreign function).</li>
</ul>

<h5 id="unsafe-functions" class="section-header"><a href="#unsafe-functions">6.1.3.2.1 Unsafe functions</a></h5>
<p>Unsafe functions are functions that are not safe in all contexts and/or for all
possible inputs. Such a function must be prefixed with the keyword <code>unsafe</code> and
can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>

<h5 id="unsafe-blocks" class="section-header"><a href="#unsafe-blocks">6.1.3.2.2 Unsafe blocks</a></h5>
<p>A block of code can be prefixed with the <code>unsafe</code> keyword, to permit calling
<code>unsafe</code> functions or dereferencing raw pointers within a safe function.</p>

<p>When a programmer has sufficient conviction that a sequence of potentially
unsafe operations is actually safe, they can encapsulate that sequence (taken
as a whole) within an <code>unsafe</code> block. The compiler will consider uses of such
code safe, in the surrounding context.</p>

<p>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware
or implement features not directly present in the language. For example, Rust
provides the language features necessary to implement memory-safe concurrency
in the language but the implementation of threads and message passing is in the
standard library.</p>

<p>Rust's type system is a conservative approximation of the dynamic safety
requirements, so in some cases there is a performance cost to using safe code.
For example, a doubly-linked list is not a tree structure and can only be
represented with reference-counted pointers in safe code. By using <code>unsafe</code>
blocks to represent the reverse links as raw pointers, it can be implemented
with only boxes.</p>

<h5 id="behavior-considered-undefined" class="section-header"><a href="#behavior-considered-undefined">6.1.3.2.3 Behavior considered undefined</a></h5>
<p>The following is a list of behavior which is forbidden in all Rust code,
including within <code>unsafe</code> blocks and <code>unsafe</code> functions. Type checking provides
the guarantee that these issues are never caused by safe code.</p>

<ul>
<li>Data races</li>
<li>Dereferencing a null/dangling raw pointer</li>
<li>Reads of <a href="http://llvm.org/docs/LangRef.html#undefined-values">undef</a>
(uninitialized) memory</li>
<li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing
rules</a>
with raw pointers (a subset of the rules used by C)</li>
<li><code>&amp;mut</code> and <code>&amp;</code> follow LLVM’s scoped <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> model, except if the <code>&amp;T</code>
contains an <code>UnsafeCell&lt;U&gt;</code>. Unsafe code must not violate these aliasing
guarantees.</li>
<li>Mutating non-mutable data (that is, data reached through a shared reference or
data owned by a <code>let</code> binding), unless that data is contained within an <code>UnsafeCell&lt;U&gt;</code>.</li>
<li>Invoking undefined behavior via compiler intrinsics:

<ul>
<li>Indexing outside of the bounds of an object with <code>std::ptr::offset</code>
(<code>offset</code> intrinsic), with
the exception of one byte past the end which is permitted.</li>
<li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy32</code>/<code>memcpy64</code>
intrinsics) on overlapping buffers</li>
</ul></li>
<li>Invalid values in primitive types, even in private fields/locals:

<ul>
<li>Dangling/null references or boxes</li>
<li>A value other than <code>false</code> (0) or <code>true</code> (1) in a <code>bool</code></li>
<li>A discriminant in an <code>enum</code> not included in the type definition</li>
<li>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code></li>
<li>Non-UTF-8 byte sequences in a <code>str</code></li>
</ul></li>
<li>Unwinding into Rust from foreign code or unwinding from Rust into foreign
code. Rust's failure system is not compatible with exception handling in
other languages. Unwinding must be caught and handled at FFI boundaries.</li>
</ul>

<h5 id="behavior-not-considered-unsafe" class="section-header"><a href="#behavior-not-considered-unsafe">6.1.3.2.4 Behavior not considered unsafe</a></h5>
<p>This is a list of behavior not considered <em>unsafe</em> in Rust terms, but that may
be undesired.</p>

<ul>
<li>Deadlocks</li>
<li>Leaks of memory and other resources</li>
<li>Exiting without calling destructors</li>
<li>Integer overflow

<ul>
<li>Overflow is considered "unexpected" behavior and is always user-error,
unless the <code>wrapping</code> primitives are used. In non-optimized builds, the compiler
will insert debug checks that panic on overflow, but in optimized builds overflow
instead results in wrapped values. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a> for the rationale and more details.</li>
</ul></li>
</ul>

<h4 id="diverging-functions" class="section-header"><a href="#diverging-functions">6.1.3.3 Diverging functions</a></h4>
<p>A special kind of function can be declared with a <code>!</code> character where the
output type would normally be. For example:</p>
<span class="rusttest">fn main() {
    fn my_err(s: &amp;str) -&gt; ! {
        println!("{}", s);
        panic!();
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">my_err</span>(<span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="op">!</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">s</span>);
    <span class="macro">panic</span><span class="macro">!</span>();
}</pre>

<p>We call such functions "diverging" because they never return a value to the
caller. Every control path in a diverging function must end with a <code>panic!()</code> or
a call to another diverging function on every control path. The <code>!</code> annotation
does <em>not</em> denote a type.</p>

<p>It might be necessary to declare a diverging function because as mentioned
previously, the typechecker checks that every control path in a function ends
with a <a href="#return-expressions"><code>return</code></a> or diverging expression. So, if <code>my_err</code>
were declared without the <code>!</code> annotation, the following code would not
typecheck:</p>
<span class="rusttest">fn main() {
    fn my_err(s: &amp;str) -&gt; ! { panic!() }
    
    fn f(i: i32) -&gt; i32 {
        if i == 42 {
            return 42;
        }
        else {
            my_err("Bad number!");
        }
    }
    
}</span><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">f</span>(<span class="ident">i</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="kw">if</span> <span class="ident">i</span> <span class="op">==</span> <span class="number">42</span> {
        <span class="kw">return</span> <span class="number">42</span>;
    }
    <span class="kw">else</span> {
        <span class="ident">my_err</span>(<span class="string">"Bad number!"</span>);
    }
}</pre>

<p>This will not compile without the <code>!</code> annotation on <code>my_err</code>, since the <code>else</code>
branch of the conditional in <code>f</code> does not return an <code>i32</code>, as required by the
signature of <code>f</code>. Adding the <code>!</code> annotation to <code>my_err</code> informs the
typechecker that, should control ever enter <code>my_err</code>, no further type judgments
about <code>f</code> need to hold, since control will never resume in any context that
relies on those judgments. Thus the return type on <code>f</code> only needs to reflect
the <code>if</code> branch of the conditional.</p>

<h4 id="extern-functions" class="section-header"><a href="#extern-functions">6.1.3.4 Extern functions</a></h4>
<p>Extern functions are part of Rust's foreign function interface, providing the
opposite functionality to <a href="#external-blocks">external blocks</a>. Whereas
external blocks allow Rust code to call foreign code, extern functions with
bodies defined in Rust code <em>can be called by foreign code</em>. They are defined
in the same way as any other Rust function, except that they have the <code>extern</code>
modifier.</p>
<span class="rusttest">fn main() {
    // Declares an extern fn, the ABI defaults to "C"
    extern fn new_i32() -&gt; i32 { 0 }
    
    // Declares an extern fn with "stdcall" ABI
    extern "stdcall" fn new_i32_stdcall() -&gt; i32 { 0 }
    
}</span><pre class="rust rust-example-rendered"><span class="comment">// Declares an extern fn, the ABI defaults to "C"</span>
<span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">new_i32</span>() <span class="op">-&gt;</span> <span class="ident">i32</span> { <span class="number">0</span> }

<span class="comment">// Declares an extern fn with "stdcall" ABI</span>
<span class="kw">extern</span> <span class="string">"stdcall"</span> <span class="kw">fn</span> <span class="ident">new_i32_stdcall</span>() <span class="op">-&gt;</span> <span class="ident">i32</span> { <span class="number">0</span> }</pre>

<p>Unlike normal functions, extern fns have type <code>extern "ABI" fn()</code>. This is the
same type as the functions declared in an extern block.</p>
<span class="rusttest">fn main() {
    extern fn new_i32() -&gt; i32 { 0 }
    let fptr: extern "C" fn() -&gt; i32 = new_i32;
    
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">fptr</span>: <span class="kw">extern</span> <span class="string">"C"</span> <span class="kw">fn</span>() <span class="op">-&gt;</span> <span class="ident">i32</span> <span class="op">=</span> <span class="ident">new_i32</span>;</pre>

<p>Extern functions may be called directly from Rust code as Rust uses large,
contiguous stack segments like C.</p>

<h3 id="type-aliases" class="section-header"><a href="#type-aliases">6.1.4 Type aliases</a></h3>
<p>A <em>type alias</em> defines a new name for an existing <a href="#types">type</a>. Type
aliases are declared with the keyword <code>type</code>. Every value has a single,
specific type, but may implement several different traits, or be compatible with
several different type constraints.</p>

<p>For example, the following defines the type <code>Point</code> as a synonym for the type
<code>(u8, u8)</code>, the type of pairs of unsigned 8 bit integers:</p>
<span class="rusttest">fn main() {
    type Point = (u8, u8);
    let p: Point = (41, 68);
    
}</span><pre class="rust rust-example-rendered"><span class="kw">type</span> <span class="ident">Point</span> <span class="op">=</span> (<span class="ident">u8</span>, <span class="ident">u8</span>);
<span class="kw">let</span> <span class="ident">p</span>: <span class="ident">Point</span> <span class="op">=</span> (<span class="number">41</span>, <span class="number">68</span>);</pre>

<h3 id="structures" class="section-header"><a href="#structures">6.1.5 Structures</a></h3>
<p>A <em>structure</em> is a nominal <a href="#structure-types">structure type</a> defined with the
keyword <code>struct</code>.</p>

<p>An example of a <code>struct</code> item and its use:</p>
<span class="rusttest">fn main() {
    struct Point {x: i32, y: i32}
    let p = Point {x: 10, y: 11};
    let px: i32 = p.x;
    
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">Point</span> {<span class="ident">x</span>: <span class="ident">i32</span>, <span class="ident">y</span>: <span class="ident">i32</span>}
<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Point</span> {<span class="ident">x</span>: <span class="number">10</span>, <span class="ident">y</span>: <span class="number">11</span>};
<span class="kw">let</span> <span class="ident">px</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="ident">p</span>.<span class="ident">x</span>;</pre>

<p>A <em>tuple structure</em> is a nominal <a href="#tuple-types">tuple type</a>, also defined with
the keyword <code>struct</code>. For example:</p>
<span class="rusttest">fn main() {
    struct Point(i32, i32);
    let p = Point(10, 11);
    let px: i32 = match p { Point(x, _) =&gt; x };
    
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">Point</span>(<span class="ident">i32</span>, <span class="ident">i32</span>);
<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Point</span>(<span class="number">10</span>, <span class="number">11</span>);
<span class="kw">let</span> <span class="ident">px</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">p</span> { <span class="ident">Point</span>(<span class="ident">x</span>, _) <span class="op">=&gt;</span> <span class="ident">x</span> };</pre>

<p>A <em>unit-like struct</em> is a structure without any fields, defined by leaving off
the list of fields entirely. Such types will have a single value. For example:</p>
<span class="rusttest">fn main() {
    struct Cookie;
    let c = [Cookie, Cookie, Cookie, Cookie];
    
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">Cookie</span>;
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> [<span class="ident">Cookie</span>, <span class="ident">Cookie</span>, <span class="ident">Cookie</span>, <span class="ident">Cookie</span>];</pre>

<p>The precise memory layout of a structure is not specified. One can specify a
particular layout using the <a href="#ffi-attributes"><code>repr</code> attribute</a>.</p>

<h3 id="enumerations" class="section-header"><a href="#enumerations">6.1.6 Enumerations</a></h3>
<p>An <em>enumeration</em> is a simultaneous definition of a nominal <a href="#enumerated-types">enumerated
type</a> as well as a set of <em>constructors</em>, that can be used
to create or pattern-match values of the corresponding enumerated type.</p>

<p>Enumerations are declared with the keyword <code>enum</code>.</p>

<p>An example of an <code>enum</code> item and its use:</p>
<span class="rusttest">fn main() {
    enum Animal {
        Dog,
        Cat,
    }
    
    let mut a: Animal = Animal::Dog;
    a = Animal::Cat;
    
}</span><pre class="rust rust-example-rendered"><span class="kw">enum</span> <span class="ident">Animal</span> {
    <span class="ident">Dog</span>,
    <span class="ident">Cat</span>,
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span>: <span class="ident">Animal</span> <span class="op">=</span> <span class="ident">Animal</span>::<span class="ident">Dog</span>;
<span class="ident">a</span> <span class="op">=</span> <span class="ident">Animal</span>::<span class="ident">Cat</span>;</pre>

<p>Enumeration constructors can have either named or unnamed fields:</p>
<span class="rusttest">fn main() {
    enum Animal {
        Dog (String, f64),
        Cat { name: String, weight: f64 }
    }
    
    let mut a: Animal = Animal::Dog("Cocoa".to_string(), 37.2);
    a = Animal::Cat { name: "Spotty".to_string(), weight: 2.7 };
    
}</span><pre class="rust rust-example-rendered"><span class="kw">enum</span> <span class="ident">Animal</span> {
    <span class="ident">Dog</span> (<span class="ident">String</span>, <span class="ident">f64</span>),
    <span class="ident">Cat</span> { <span class="ident">name</span>: <span class="ident">String</span>, <span class="ident">weight</span>: <span class="ident">f64</span> }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span>: <span class="ident">Animal</span> <span class="op">=</span> <span class="ident">Animal</span>::<span class="ident">Dog</span>(<span class="string">"Cocoa"</span>.<span class="ident">to_string</span>(), <span class="number">37.2</span>);
<span class="ident">a</span> <span class="op">=</span> <span class="ident">Animal</span>::<span class="ident">Cat</span> { <span class="ident">name</span>: <span class="string">"Spotty"</span>.<span class="ident">to_string</span>(), <span class="ident">weight</span>: <span class="number">2.7</span> };</pre>

<p>In this example, <code>Cat</code> is a <em>struct-like enum variant</em>,
whereas <code>Dog</code> is simply called an enum variant.</p>

<p>Enums have a discriminant. You can assign them explicitly:</p>
<span class="rusttest">fn main() {
    enum Foo {
        Bar = 123,
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">enum</span> <span class="ident">Foo</span> {
    <span class="ident">Bar</span> <span class="op">=</span> <span class="number">123</span>,
}</pre>

<p>If a discriminant isn't assigned, they start at zero, and add one for each
variant, in order.</p>

<p>You can cast an enum to get this value:</p>
<span class="rusttest">fn main() {
    enum Foo { Bar = 123 }
    let x = Foo::Bar as u32; // x is now 123u32
    
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Foo</span>::<span class="ident">Bar</span> <span class="kw">as</span> <span class="ident">u32</span>; <span class="comment">// x is now 123u32</span></pre>

<p>This only works as long as none of the variants have data attached. If
it were <code>Bar(i32)</code>, this is disallowed.</p>

<h3 id="constant-items" class="section-header"><a href="#constant-items">6.1.7 Constant items</a></h3>
<p>A <em>constant item</em> is a named <em>constant value</em> which is not associated with a
specific memory location in the program. Constants are essentially inlined
wherever they are used, meaning that they are copied directly into the relevant
context when used. References to the same constant are not necessarily
guaranteed to refer to the same memory address.</p>

<p>Constant values must not have destructors, and otherwise permit most forms of
data. Constants may refer to the address of other constants, in which case the
address will have the <code>static</code> lifetime. The compiler is, however, still at
liberty to translate the constant many times, so the address referred to may not
be stable.</p>

<p>Constants must be explicitly typed. The type may be <code>bool</code>, <code>char</code>, a number, or
a type derived from those primitive types. The derived types are references with
the <code>static</code> lifetime, fixed-size arrays, tuples, enum variants, and structs.</p>
<span class="rusttest">fn main() {
    const BIT1: u32 = 1 &lt;&lt; 0;
    const BIT2: u32 = 1 &lt;&lt; 1;
    
    const BITS: [u32; 2] = [BIT1, BIT2];
    const STRING: &amp;'static str = "bitstring";
    
    struct BitsNStrings&lt;'a&gt; {
        mybits: [u32; 2],
        mystring: &amp;'a str
    }
    
    const BITS_N_STRINGS: BitsNStrings&lt;'static&gt; = BitsNStrings {
        mybits: BITS,
        mystring: STRING
    };
    
}</span><pre class="rust rust-example-rendered"><span class="kw">const</span> <span class="ident">BIT1</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">1</span> <span class="op">&lt;&lt;</span> <span class="number">0</span>;
<span class="kw">const</span> <span class="ident">BIT2</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">1</span> <span class="op">&lt;&lt;</span> <span class="number">1</span>;

<span class="kw">const</span> <span class="ident">BITS</span>: [<span class="ident">u32</span>; <span class="number">2</span>] <span class="op">=</span> [<span class="ident">BIT1</span>, <span class="ident">BIT2</span>];
<span class="kw">const</span> <span class="ident">STRING</span>: <span class="kw-2">&amp;</span><span class="lifetime">'static</span> <span class="ident">str</span> <span class="op">=</span> <span class="string">"bitstring"</span>;

<span class="kw">struct</span> <span class="ident">BitsNStrings</span><span class="op">&lt;</span><span class="lifetime">'a</span><span class="op">&gt;</span> {
    <span class="ident">mybits</span>: [<span class="ident">u32</span>; <span class="number">2</span>],
    <span class="ident">mystring</span>: <span class="kw-2">&amp;</span><span class="lifetime">'a</span> <span class="ident">str</span>
}

<span class="kw">const</span> <span class="ident">BITS_N_STRINGS</span>: <span class="ident">BitsNStrings</span><span class="op">&lt;</span><span class="lifetime">'static</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitsNStrings</span> {
    <span class="ident">mybits</span>: <span class="ident">BITS</span>,
    <span class="ident">mystring</span>: <span class="ident">STRING</span>
};</pre>

<h3 id="static-items" class="section-header"><a href="#static-items">6.1.8 Static items</a></h3>
<p>A <em>static item</em> is similar to a <em>constant</em>, except that it represents a precise
memory location in the program. A static is never "inlined" at the usage site,
and all references to it refer to the same memory location. Static items have
the <code>static</code> lifetime, which outlives all other lifetimes in a Rust program.
Static items may be placed in read-only memory if they do not contain any
interior mutability.</p>

<p>Statics may contain interior mutability through the <code>UnsafeCell</code> language item.
All access to a static is safe, but there are a number of restrictions on
statics:</p>

<ul>
<li>Statics may not contain any destructors.</li>
<li>The types of static values must ascribe to <code>Sync</code> to allow thread-safe access.</li>
<li>Statics may not refer to other statics by value, only by reference.</li>
<li>Constants cannot refer to statics.</li>
</ul>

<p>Constants should in general be preferred over statics, unless large amounts of
data are being stored, or single-address and mutability properties are required.</p>

<h4 id="mutable-statics" class="section-header"><a href="#mutable-statics">6.1.8.1 Mutable statics</a></h4>
<p>If a static item is declared with the <code>mut</code> keyword, then it is allowed to
be modified by the program. One of Rust's goals is to make concurrency bugs
hard to run into, and this is obviously a very large source of race conditions
or other bugs. For this reason, an <code>unsafe</code> block is required when either
reading or writing a mutable static variable. Care should be taken to ensure
that modifications to a mutable static are safe with respect to other threads
running in the same process.</p>

<p>Mutable statics are still very useful, however. They can be used with C
libraries and can also be bound from C libraries (in an <code>extern</code> block).</p>
<span class="rusttest">fn main() {
    fn atomic_add(_: &amp;mut u32, _: u32) -&gt; u32 { 2 }
    
    static mut LEVELS: u32 = 0;
    
    // This violates the idea of no shared state, and this doesn't internally
    // protect against races, so this function is `unsafe`
    unsafe fn bump_levels_unsafe1() -&gt; u32 {
        let ret = LEVELS;
        LEVELS += 1;
        return ret;
    }
    
    // Assuming that we have an atomic_add function which returns the old value,
    // this function is "safe" but the meaning of the return value may not be what
    // callers expect, so it's still marked as `unsafe`
    unsafe fn bump_levels_unsafe2() -&gt; u32 {
        return atomic_add(&amp;mut LEVELS, 1);
    }
    
}</span><pre class="rust rust-example-rendered">
<span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">LEVELS</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">0</span>;

<span class="comment">// This violates the idea of no shared state, and this doesn't internally</span>
<span class="comment">// protect against races, so this function is `unsafe`</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">bump_levels_unsafe1</span>() <span class="op">-&gt;</span> <span class="ident">u32</span> {
    <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="ident">LEVELS</span>;
    <span class="ident">LEVELS</span> <span class="op">+=</span> <span class="number">1</span>;
    <span class="kw">return</span> <span class="ident">ret</span>;
}

<span class="comment">// Assuming that we have an atomic_add function which returns the old value,</span>
<span class="comment">// this function is "safe" but the meaning of the return value may not be what</span>
<span class="comment">// callers expect, so it's still marked as `unsafe`</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">bump_levels_unsafe2</span>() <span class="op">-&gt;</span> <span class="ident">u32</span> {
    <span class="kw">return</span> <span class="ident">atomic_add</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">LEVELS</span>, <span class="number">1</span>);
}</pre>

<p>Mutable statics have the same restrictions as normal statics, except that the
type of the value is not required to ascribe to <code>Sync</code>.</p>

<h3 id="traits" class="section-header"><a href="#traits">6.1.9 Traits</a></h3>
<p>A <em>trait</em> describes an abstract interface that types can
implement. This interface consists of associated items, which come in
three varieties:</p>

<ul>
<li>functions</li>
<li>constants</li>
<li>types</li>
</ul>

<p>Associated functions whose first parameter is named <code>self</code> are called
methods and may be invoked using <code>.</code> notation (e.g., <code>x.foo()</code>).</p>

<p>All traits define an implicit type parameter <code>Self</code> that refers to
"the type that is implementing this interface". Traits may also
contain additional type parameters. These type parameters (including
<code>Self</code>) may be constrained by other traits and so forth as usual.</p>

<p>Trait bounds on <code>Self</code> are considered "supertraits". These are
required to be acyclic.  Supertraits are somewhat different from other
constraints in that they affect what methods are available in the
vtable when the trait is used as a <a href="#trait-objects">trait object</a>.</p>

<p>Traits are implemented for specific types through separate
<a href="#implementations">implementations</a>.</p>

<p>Consider the following trait:</p>
<span class="rusttest">fn main() {
    type Surface = i32;
    type BoundingBox = i32;
    trait Shape {
        fn draw(&amp;self, Surface);
        fn bounding_box(&amp;self) -&gt; BoundingBox;
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">trait</span> <span class="ident">Shape</span> {
    <span class="kw">fn</span> <span class="ident">draw</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">Surface</span>);
    <span class="kw">fn</span> <span class="ident">bounding_box</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">BoundingBox</span>;
}</pre>

<p>This defines a trait with two methods. All values that have
<a href="#implementations">implementations</a> of this trait in scope can have their
<code>draw</code> and <code>bounding_box</code> methods called, using <code>value.bounding_box()</code>
<a href="#method-call-expressions">syntax</a>.</p>

<p>Traits can include default implementations of methods, as in:</p>
<span class="rusttest">fn main() {
    trait Foo {
        fn bar(&amp;self);
        fn baz(&amp;self) { println!("We called baz."); }
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">trait</span> <span class="ident">Foo</span> {
    <span class="kw">fn</span> <span class="ident">bar</span>(<span class="kw-2">&amp;</span><span class="self">self</span>);
    <span class="kw">fn</span> <span class="ident">baz</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) { <span class="macro">println</span><span class="macro">!</span>(<span class="string">"We called baz."</span>); }
}</pre>

<p>Here the <code>baz</code> method has a default implementation, so types that implement
<code>Foo</code> need only implement <code>bar</code>. It is also possible for implementing types
to override a method that has a default implementation.</p>

<p>Type parameters can be specified for a trait to make it generic. These appear
after the trait name, using the same syntax used in <a href="#generic-functions">generic
functions</a>.</p>
<span class="rusttest">fn main() {
    trait Seq&lt;T&gt; {
        fn len(&amp;self) -&gt; u32;
        fn elt_at(&amp;self, n: u32) -&gt; T;
        fn iter&lt;F&gt;(&amp;self, F) where F: Fn(T);
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">trait</span> <span class="ident">Seq</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">len</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u32</span>;
    <span class="kw">fn</span> <span class="ident">elt_at</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">n</span>: <span class="ident">u32</span>) <span class="op">-&gt;</span> <span class="ident">T</span>;
    <span class="kw">fn</span> <span class="ident">iter</span><span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">F</span>) <span class="kw">where</span> <span class="ident">F</span>: <span class="ident">Fn</span>(<span class="ident">T</span>);
}</pre>

<p>It is also possible to define associated types for a trait. Consider the
following example of a <code>Container</code> trait. Notice how the type is available
for use in the method signatures:</p>
<span class="rusttest">fn main() {
    trait Container {
        type E;
        fn empty() -&gt; Self;
        fn insert(&amp;mut self, Self::E);
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">trait</span> <span class="ident">Container</span> {
    <span class="kw">type</span> <span class="ident">E</span>;
    <span class="kw">fn</span> <span class="ident">empty</span>() <span class="op">-&gt;</span> <span class="kw">Self</span>;
    <span class="kw">fn</span> <span class="ident">insert</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">Self</span>::<span class="ident">E</span>);
}</pre>

<p>In order for a type to implement this trait, it must not only provide
implementations for every method, but it must specify the type <code>E</code>. Here's
an implementation of <code>Container</code> for the standard library type <code>Vec</code>:</p>
<span class="rusttest">fn main() {
    trait Container {
        type E;
        fn empty() -&gt; Self;
        fn insert(&amp;mut self, Self::E);
    }
    impl&lt;T&gt; Container for Vec&lt;T&gt; {
        type E = T;
        fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
        fn insert(&amp;mut self, x: T) { self.push(x); }
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Container</span> <span class="kw">for</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">type</span> <span class="ident">E</span> <span class="op">=</span> <span class="ident">T</span>;
    <span class="kw">fn</span> <span class="ident">empty</span>() <span class="op">-&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> { <span class="ident">Vec</span>::<span class="ident">new</span>() }
    <span class="kw">fn</span> <span class="ident">insert</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">x</span>: <span class="ident">T</span>) { <span class="self">self</span>.<span class="ident">push</span>(<span class="ident">x</span>); }
}</pre>

<p>Generic functions may use traits as <em>bounds</em> on their type parameters. This
will have two effects:</p>

<ul>
<li>Only types that have the trait may instantiate the parameter.</li>
<li>Within the generic function, the methods of the trait can be
called on values that have the parameter's type.</li>
</ul>

<p>For example:</p>
<span class="rusttest">fn main() {
    type Surface = i32;
    trait Shape { fn draw(&amp;self, Surface); }
    fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
        sh.draw(surface);
        sh.draw(surface);
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">draw_twice</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Shape</span><span class="op">&gt;</span>(<span class="ident">surface</span>: <span class="ident">Surface</span>, <span class="ident">sh</span>: <span class="ident">T</span>) {
    <span class="ident">sh</span>.<span class="ident">draw</span>(<span class="ident">surface</span>);
    <span class="ident">sh</span>.<span class="ident">draw</span>(<span class="ident">surface</span>);
}</pre>

<p>Traits also define a <a href="#trait-objects">trait object</a> with the same
name as the trait. Values of this type are created by coercing from a
pointer of some specific type to a pointer of trait type. For example,
<code>&amp;T</code> could be coerced to <code>&amp;Shape</code> if <code>T: Shape</code> holds (and similarly
for <code>Box&lt;T&gt;</code>). This coercion can either be implicit or
<a href="#type-cast-expressions">explicit</a>. Here is an example of an explicit
coercion:</p>
<span class="rusttest">fn main() {
    trait Shape { }
    impl Shape for i32 { }
    let mycircle = 0i32;
    let myshape: Box&lt;Shape&gt; = Box::new(mycircle) as Box&lt;Shape&gt;;
    
}</span><pre class="rust rust-example-rendered"><span class="kw">trait</span> <span class="ident">Shape</span> { }
<span class="kw">impl</span> <span class="ident">Shape</span> <span class="kw">for</span> <span class="ident">i32</span> { }
<span class="kw">let</span> <span class="ident">mycircle</span> <span class="op">=</span> <span class="number">0i32</span>;
<span class="kw">let</span> <span class="ident">myshape</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Shape</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">mycircle</span>) <span class="kw">as</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Shape</span><span class="op">&gt;</span>;</pre>

<p>The resulting value is a box containing the value that was cast, along with
information that identifies the methods of the implementation that was used.
Values with a trait type can have <a href="#method-call-expressions">methods called</a> on
them, for any method in the trait, and can be used to instantiate type
parameters that are bounded by the trait.</p>

<p>Trait methods may be static, which means that they lack a <code>self</code> argument.
This means that they can only be called with function call syntax (<code>f(x)</code>) and
not method call syntax (<code>obj.f()</code>). The way to refer to the name of a static
method is to qualify it with the trait name, treating the trait name like a
module. For example:</p>
<span class="rusttest">fn main() {
    trait Num {
        fn from_i32(n: i32) -&gt; Self;
    }
    impl Num for f64 {
        fn from_i32(n: i32) -&gt; f64 { n as f64 }
    }
    let x: f64 = Num::from_i32(42);
    
}</span><pre class="rust rust-example-rendered"><span class="kw">trait</span> <span class="ident">Num</span> {
    <span class="kw">fn</span> <span class="ident">from_i32</span>(<span class="ident">n</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="kw">Self</span>;
}
<span class="kw">impl</span> <span class="ident">Num</span> <span class="kw">for</span> <span class="ident">f64</span> {
    <span class="kw">fn</span> <span class="ident">from_i32</span>(<span class="ident">n</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> { <span class="ident">n</span> <span class="kw">as</span> <span class="ident">f64</span> }
}
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">f64</span> <span class="op">=</span> <span class="ident">Num</span>::<span class="ident">from_i32</span>(<span class="number">42</span>);</pre>

<p>Traits may inherit from other traits. Consider the following example:</p>
<span class="rusttest">fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">trait</span> <span class="ident">Shape</span> { <span class="kw">fn</span> <span class="ident">area</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span>; }
<span class="kw">trait</span> <span class="ident">Circle</span> : <span class="ident">Shape</span> { <span class="kw">fn</span> <span class="ident">radius</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span>; }</pre>

<p>The syntax <code>Circle : Shape</code> means that types that implement <code>Circle</code> must also
have an implementation for <code>Shape</code>. Multiple supertraits are separated by <code>+</code>,
<code>trait Circle : Shape + PartialEq { }</code>. In an implementation of <code>Circle</code> for a
given type <code>T</code>, methods can refer to <code>Shape</code> methods, since the typechecker
checks that any type with an implementation of <code>Circle</code> also has an
implementation of <code>Shape</code>:</p>
<span class="rusttest">fn main() {
    struct Foo;
    
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    impl Shape for Foo {
        fn area(&amp;self) -&gt; f64 {
            0.0
        }
    }
    impl Circle for Foo {
        fn radius(&amp;self) -&gt; f64 {
            println!("calling area: {}", self.area());
    
            0.0
        }
    }
    
    let c = Foo;
    c.radius();
    
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">Foo</span>;

<span class="kw">trait</span> <span class="ident">Shape</span> { <span class="kw">fn</span> <span class="ident">area</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span>; }
<span class="kw">trait</span> <span class="ident">Circle</span> : <span class="ident">Shape</span> { <span class="kw">fn</span> <span class="ident">radius</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span>; }
<span class="kw">impl</span> <span class="ident">Circle</span> <span class="kw">for</span> <span class="ident">Foo</span> {
    <span class="kw">fn</span> <span class="ident">radius</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">"calling area: {}"</span>, <span class="self">self</span>.<span class="ident">area</span>());

        <span class="number">0.0</span>
    }
}

<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Foo</span>;
<span class="ident">c</span>.<span class="ident">radius</span>();</pre>

<p>In type-parameterized functions, methods of the supertrait may be called on
values of subtrait-bound type parameters. Referring to the previous example of
<code>trait Circle : Shape</code>:</p>
<span class="rusttest">fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    fn radius_times_area&lt;T: Circle&gt;(c: T) -&gt; f64 {
        // `c` is both a Circle and a Shape
        c.radius() * c.area()
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">radius_times_area</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Circle</span><span class="op">&gt;</span>(<span class="ident">c</span>: <span class="ident">T</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
    <span class="comment">// `c` is both a Circle and a Shape</span>
    <span class="ident">c</span>.<span class="ident">radius</span>() <span class="op">*</span> <span class="ident">c</span>.<span class="ident">area</span>()
}</pre>

<p>Likewise, supertrait methods may also be called on trait objects.</p>
<span class="rusttest">fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    impl Shape for i32 { fn area(&amp;self) -&gt; f64 { 0.0 } }
    impl Circle for i32 { fn radius(&amp;self) -&gt; f64 { 0.0 } }
    let mycircle = 0i32;
    let mycircle = Box::new(mycircle) as Box&lt;Circle&gt;;
    let nonsense = mycircle.radius() * mycircle.area();
    
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">mycircle</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">mycircle</span>) <span class="kw">as</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Circle</span><span class="op">&gt;</span>;
<span class="kw">let</span> <span class="ident">nonsense</span> <span class="op">=</span> <span class="ident">mycircle</span>.<span class="ident">radius</span>() <span class="op">*</span> <span class="ident">mycircle</span>.<span class="ident">area</span>();</pre>

<h3 id="implementations" class="section-header"><a href="#implementations">6.1.10 Implementations</a></h3>
<p>An <em>implementation</em> is an item that implements a <a href="#traits">trait</a> for a
specific type.</p>

<p>Implementations are defined with the keyword <code>impl</code>.</p>
<span class="rusttest">fn main() {
    #[derive(Copy, Clone)]
    struct Point {x: f64, y: f64};
    type Surface = i32;
    struct BoundingBox {x: f64, y: f64, width: f64, height: f64};
    trait Shape { fn draw(&amp;self, Surface); fn bounding_box(&amp;self) -&gt; BoundingBox; }
    fn do_draw_circle(s: Surface, c: Circle) { }
    struct Circle {
        radius: f64,
        center: Point,
    }
    
    impl Copy for Circle {}
    
    impl Clone for Circle {
        fn clone(&amp;self) -&gt; Circle { *self }
    }
    
    impl Shape for Circle {
        fn draw(&amp;self, s: Surface) { do_draw_circle(s, *self); }
        fn bounding_box(&amp;self) -&gt; BoundingBox {
            let r = self.radius;
            BoundingBox {
                x: self.center.x - r,
                y: self.center.y - r,
                width: 2.0 * r,
                height: 2.0 * r,
            }
        }
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">Circle</span> {
    <span class="ident">radius</span>: <span class="ident">f64</span>,
    <span class="ident">center</span>: <span class="ident">Point</span>,
}

<span class="kw">impl</span> <span class="ident">Copy</span> <span class="kw">for</span> <span class="ident">Circle</span> {}

<span class="kw">impl</span> <span class="ident">Clone</span> <span class="kw">for</span> <span class="ident">Circle</span> {
    <span class="kw">fn</span> <span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Circle</span> { <span class="op">*</span><span class="self">self</span> }
}

<span class="kw">impl</span> <span class="ident">Shape</span> <span class="kw">for</span> <span class="ident">Circle</span> {
    <span class="kw">fn</span> <span class="ident">draw</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">s</span>: <span class="ident">Surface</span>) { <span class="ident">do_draw_circle</span>(<span class="ident">s</span>, <span class="op">*</span><span class="self">self</span>); }
    <span class="kw">fn</span> <span class="ident">bounding_box</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">BoundingBox</span> {
        <span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">radius</span>;
        <span class="ident">BoundingBox</span> {
            <span class="ident">x</span>: <span class="self">self</span>.<span class="ident">center</span>.<span class="ident">x</span> <span class="op">-</span> <span class="ident">r</span>,
            <span class="ident">y</span>: <span class="self">self</span>.<span class="ident">center</span>.<span class="ident">y</span> <span class="op">-</span> <span class="ident">r</span>,
            <span class="ident">width</span>: <span class="number">2.0</span> <span class="op">*</span> <span class="ident">r</span>,
            <span class="ident">height</span>: <span class="number">2.0</span> <span class="op">*</span> <span class="ident">r</span>,
        }
    }
}</pre>

<p>It is possible to define an implementation without referring to a trait. The
methods in such an implementation can only be used as direct calls on the
values of the type that the implementation targets. In such an implementation,
the trait type and <code>for</code> after <code>impl</code> are omitted. Such implementations are
limited to nominal types (enums, structs), and the implementation must appear
in the same crate as the <code>self</code> type:</p>
<span class="rusttest">fn main() {
    struct Point {x: i32, y: i32}
    
    impl Point {
        fn log(&amp;self) {
            println!("Point is at ({}, {})", self.x, self.y);
        }
    }
    
    let my_point = Point {x: 10, y:11};
    my_point.log();
    
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">Point</span> {<span class="ident">x</span>: <span class="ident">i32</span>, <span class="ident">y</span>: <span class="ident">i32</span>}

<span class="kw">impl</span> <span class="ident">Point</span> {
    <span class="kw">fn</span> <span class="ident">log</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">"Point is at ({}, {})"</span>, <span class="self">self</span>.<span class="ident">x</span>, <span class="self">self</span>.<span class="ident">y</span>);
    }
}

<span class="kw">let</span> <span class="ident">my_point</span> <span class="op">=</span> <span class="ident">Point</span> {<span class="ident">x</span>: <span class="number">10</span>, <span class="ident">y</span>:<span class="number">11</span>};
<span class="ident">my_point</span>.<span class="ident">log</span>();</pre>

<p>When a trait <em>is</em> specified in an <code>impl</code>, all methods declared as part of the
trait must be implemented, with matching types and type parameter counts.</p>

<p>An implementation can take type parameters, which can be different from the
type parameters taken by the trait it implements. Implementation parameters
are written after the <code>impl</code> keyword.</p>
<span class="rusttest">fn main() {
    trait Seq&lt;T&gt; { fn dummy(&amp;self, _: T) { } }
    impl&lt;T&gt; Seq&lt;T&gt; for Vec&lt;T&gt; {
        /* ... */
    }
    impl Seq&lt;bool&gt; for u32 {
        /* Treat the integer as a sequence of bits */
    }
    
}</span><pre class="rust rust-example-rendered"><span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Seq</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="comment">/* ... */</span>
}
<span class="kw">impl</span> <span class="ident">Seq</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">u32</span> {
    <span class="comment">/* Treat the integer as a sequence of bits */</span>
}</pre>

<h3 id="external-blocks" class="section-header"><a href="#external-blocks">6.1.11 External blocks</a></h3>
<p>External blocks form the basis for Rust's foreign function interface.
Declarations in an external block describe symbols in external, non-Rust
libraries.</p>

<p>Functions within external blocks are declared in the same way as other Rust
functions, with the exception that they may not have a body and are instead
terminated by a semicolon.</p>

<p>Functions within external blocks may be called by Rust code, just like
functions defined in Rust. The Rust compiler automatically translates between
the Rust ABI and the foreign ABI.</p>

<p>A number of <a href="#attributes">attributes</a> control the behavior of external blocks.</p>

<p>By default external blocks assume that the library they are calling uses the
standard C "cdecl" ABI. Other ABIs may be specified using an <code>abi</code> string, as
shown here:</p>
<span class="rusttest">fn main() {
    // Interface to the Windows API
    extern "stdcall" { }
    
}</span><pre class="rust rust-example-rendered"><span class="comment">// Interface to the Windows API</span>
<span class="kw">extern</span> <span class="string">"stdcall"</span> { }</pre>

<p>The <code>link</code> attribute allows the name of the library to be specified. When
specified the compiler will attempt to link against the native library of the
specified name.</p>
<span class="rusttest">fn main() {
    #[link(name = "crypto")]
    extern { }
    
}</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">"crypto"</span>)]</span>
<span class="kw">extern</span> { }</pre>

<p>The type of a function declared in an extern block is <code>extern "abi" fn(A1, ..., An) -&gt; R</code>, where <code>A1...An</code> are the declared types of its arguments and <code>R</code> is
the declared return type.</p>

<p>It is valid to add the <code>link</code> attribute on an empty extern block. You can use
this to satisfy the linking requirements of extern blocks elsewhere in your code
(including upstream crates) instead of adding the attribute to each extern block.</p>

<h2 id="visibility-and-privacy" class="section-header"><a href="#visibility-and-privacy">6.2 Visibility and Privacy</a></h2>
<p>These two terms are often used interchangeably, and what they are attempting to
convey is the answer to the question "Can this item be used at this location?"</p>

<p>Rust's name resolution operates on a global hierarchy of namespaces. Each level
in the hierarchy can be thought of as some item. The items are one of those
mentioned above, but also include external crates. Declaring or defining a new
module can be thought of as inserting a new tree into the hierarchy at the
location of the definition.</p>

<p>To control whether interfaces can be used across modules, Rust checks each use
of an item to see whether it should be allowed or not. This is where privacy
warnings are generated, or otherwise "you used a private item of another module
and weren't allowed to."</p>

<p>By default, everything in Rust is <em>private</em>, with one exception. Enum variants
in a <code>pub</code> enum are also public by default. When an item is declared as <code>pub</code>,
it can be thought of as being accessible to the outside world. For example:</p>
<span class="rusttest">fn main() {}
// Declare a private struct
struct Foo;

// Declare a public struct with a private field
pub struct Bar {
    field: i32
}

// Declare a public enum with two public variants
pub enum State {
    PubliclyAccessibleState,
    PubliclyAccessibleState2,
}
</span><pre class="rust rust-example-rendered"><span class="comment">// Declare a private struct</span>
<span class="kw">struct</span> <span class="ident">Foo</span>;

<span class="comment">// Declare a public struct with a private field</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Bar</span> {
    <span class="ident">field</span>: <span class="ident">i32</span>
}

<span class="comment">// Declare a public enum with two public variants</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">State</span> {
    <span class="ident">PubliclyAccessibleState</span>,
    <span class="ident">PubliclyAccessibleState2</span>,
}</pre>

<p>With the notion of an item being either public or private, Rust allows item
accesses in two cases:</p>

<ol>
<li>If an item is public, then it can be used externally through any of its
public ancestors.</li>
<li>If an item is private, it may be accessed by the current module and its
descendants.</li>
</ol>

<p>These two cases are surprisingly powerful for creating module hierarchies
exposing public APIs while hiding internal implementation details. To help
explain, here's a few use cases and what they would entail:</p>

<ul>
<li><p>A library developer needs to expose functionality to crates which link
against their library. As a consequence of the first case, this means that
anything which is usable externally must be <code>pub</code> from the root down to the
destination item. Any private item in the chain will disallow external
accesses.</p></li>
<li><p>A crate needs a global available "helper module" to itself, but it doesn't
want to expose the helper module as a public API. To accomplish this, the
root of the crate's hierarchy would have a private module which then
internally has a "public API". Because the entire crate is a descendant of
the root, then the entire local crate can access this private module through
the second case.</p></li>
<li><p>When writing unit tests for a module, it's often a common idiom to have an
immediate child of the module to-be-tested named <code>mod test</code>. This module
could access any items of the parent module through the second case, meaning
that internal implementation details could also be seamlessly tested from the
child module.</p></li>
</ul>

<p>In the second case, it mentions that a private item "can be accessed" by the
current module and its descendants, but the exact meaning of accessing an item
depends on what the item is. Accessing a module, for example, would mean
looking inside of it (to import more items). On the other hand, accessing a
function would mean that it is invoked. Additionally, path expressions and
import statements are considered to access an item in the sense that the
import/expression is only valid if the destination is in the current visibility
scope.</p>

<p>Here's an example of a program which exemplifies the three cases outlined
above:</p>
<span class="rusttest">// This module is private, meaning that no external crate can access this
// module. Because it is private at the root of this current crate, however, any
// module in the crate may access any publicly visible item in this module.
mod crate_helper_module {

    // This function can be used by anything in the current crate
    pub fn crate_helper() {}

    // This function *cannot* be used by anything else in the crate. It is not
    // publicly visible outside of the `crate_helper_module`, so only this
    // current module and its descendants may access it.
    fn implementation_detail() {}
}

// This function is "public to the root" meaning that it's available to external
// crates linking against this one.
pub fn public_api() {}

// Similarly to 'public_api', this module is public so external crates may look
// inside of it.
pub mod submodule {
    use crate_helper_module;

    pub fn my_method() {
        // Any item in the local crate may invoke the helper module's public
        // interface through a combination of the two rules above.
        crate_helper_module::crate_helper();
    }

    // This function is hidden to any module which is not a descendant of
    // `submodule`
    fn my_implementation() {}

    #[cfg(test)]
    mod test {

        #[test]
        fn test_my_implementation() {
            // Because this module is a descendant of `submodule`, it's allowed
            // to access private items inside of `submodule` without a privacy
            // violation.
            super::my_implementation();
        }
    }
}

fn main() {}
</span><pre class="rust rust-example-rendered"><span class="comment">// This module is private, meaning that no external crate can access this</span>
<span class="comment">// module. Because it is private at the root of this current crate, however, any</span>
<span class="comment">// module in the crate may access any publicly visible item in this module.</span>
<span class="kw">mod</span> <span class="ident">crate_helper_module</span> {

    <span class="comment">// This function can be used by anything in the current crate</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">crate_helper</span>() {}

    <span class="comment">// This function *cannot* be used by anything else in the crate. It is not</span>
    <span class="comment">// publicly visible outside of the `crate_helper_module`, so only this</span>
    <span class="comment">// current module and its descendants may access it.</span>
    <span class="kw">fn</span> <span class="ident">implementation_detail</span>() {}
}

<span class="comment">// This function is "public to the root" meaning that it's available to external</span>
<span class="comment">// crates linking against this one.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">public_api</span>() {}

<span class="comment">// Similarly to 'public_api', this module is public so external crates may look</span>
<span class="comment">// inside of it.</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">submodule</span> {
    <span class="kw">use</span> <span class="ident">crate_helper_module</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">my_method</span>() {
        <span class="comment">// Any item in the local crate may invoke the helper module's public</span>
        <span class="comment">// interface through a combination of the two rules above.</span>
        <span class="ident">crate_helper_module</span>::<span class="ident">crate_helper</span>()</pre></body></html>